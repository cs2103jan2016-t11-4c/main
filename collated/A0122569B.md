# A0122569B
###### doMe\ChronoInterpreter.cpp
``` cpp

#include "ChronoInterpreter.h"

ChronoInterpreter* ChronoInterpreter::_theOne = NULL;

ChronoInterpreter::ChronoInterpreter() {
}

ChronoInterpreter::~ChronoInterpreter(void) {
}

ChronoInterpreter* ChronoInterpreter::getInstance() {
	if(_theOne == NULL) {
		_theOne = new ChronoInterpreter;
	}

	return _theOne;
}

void ChronoInterpreter::interpretDateAndTime(InputTokens* tokens, int index) {
	assert(tokens);
	assert(!tokens->isOutOfBounds(index));

	setEnvironment(tokens);
	traverseTokensForIntepretation(index);
	removeNaturalLanguageTokens(index);

	return;
}

void ChronoInterpreter::setEnvironment(InputTokens* tokens) {
	_tokens = tokens;
	_dateCount = 0;
	_timeCount = 0;
	_time = 0;
	_date = 0;
	clearCache();
	
	return;
}


void ChronoInterpreter::traverseTokensForIntepretation(int index) {
	assert(!_tokens->isOutOfBounds(index));
	
	for(unsigned int i = index; i < _tokens->getSize(); i++) {
		if(_tokens->isExtensionOfAWord((int) i)) {
			continue;
		} else {
			interpretationNode((int) i);
		}
		clearCache();
	}
	
	return;
}

void ChronoInterpreter::removeNaturalLanguageTokens(int index) {
	assert(!_tokens->isOutOfBounds(index));

	for(unsigned int i = index+1; i < _tokens->getSize(); i++) {
		if(_tokens->hasMeaning("PREPOSITION", (int) i)) {
			   naturalLanguageNode((int) i);
		}
	}

	return;
}


void ChronoInterpreter::interpretationNode(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(!_tokens->isExtensionOfAWord(index));

	if(_tokens->isInteger(index)) {
		integerNode(index);
	} else if(_tokens->hasMeaning("MONTHSOFTHEYEAR", index)) {
		alphabeticMonthNode(index);
	} else if(_tokens->hasMeaning("THIS", index)) {
		thisNode(index);
	} else if(_tokens->hasMeaning("NEXT", index)) {
		nextNode(index);
	} else if(_tokens->hasMeaning("RELATIONALDATE", index)) {
		relationalDateNode(index);
	} else if(_tokens->hasMeaning("DAYSOFTHEWEEK", index)) {
		dayOfTheWeekNode(index);
	}

	return;
}

void ChronoInterpreter::integerNode(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->isInteger(index));

	int size = _tokens->getSize(index);
	if(size == 8 || size == 6) {
		sixDigitIntegerNode(index);
	} else if(size > 2 && size <= 4) {
		fourDigitIntegerNode(index);		
	} else if(size < 3) {
		twoDigitIntegerNode(index);
	}
	
	return;
}

void ChronoInterpreter::alphabeticMonthNode(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->hasMeaning("MONTHSOFTHEYEAR", index));
	
	if(dateFormatBNodeOne(index)) {
	} else if(dateFormatCNodeOne(index)) {
	}

	return;
}

void ChronoInterpreter::thisNode(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->hasMeaning("THIS", index));

	dateFormatENodeOne(index);

	return;
}

void ChronoInterpreter::nextNode(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->hasMeaning("NEXT", index));

	_nextCount = 0;
	dateFormatENodeTwo(index);

	return;
}

void ChronoInterpreter::relationalDateNode(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->hasMeaning("RELATIONALDATE", index));
	
	dateFormatENodeThree(index);

	return;
}

void ChronoInterpreter::dayOfTheWeekNode(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->hasMeaning("DAYSOFTHEWEEK", index));

	dateFormatENodeFive(index);

	return;
}

void ChronoInterpreter::naturalLanguageNode(int index) {
	assert(!_tokens->isOutOfBounds(index));

	naturalLanguageNodeOne(index);

	return;
}


void ChronoInterpreter::twoDigitIntegerNode(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->isInteger(index));
	assert(_tokens->getSize(index) < 3);
	
	if(timeRangeFormatANodeOne(index)) {
	} else if(timeRangeFormatBNodeOne(index)) {
	} else if(dateRangeFormatANodeOne(index)) {
	} else if(timeFormatBNodeOne(index)) {
	} else if(dateFormatANodeOne(index)) {
	} else if(dateFormatDNodeOne(index)) {
	}

	return;
}

void ChronoInterpreter::fourDigitIntegerNode(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->isInteger(index));
	assert(_tokens->getSize(index) <= 4);	
	assert(_tokens->getSize(index) >= 3);
	
	if(timeRangeFormatANodeOne(index)) {
	} else if(timeFormatBNodeOne(index)) {
	} else if(timeFormatANodeOne(index)) {
	}

	return;
}

void ChronoInterpreter::sixDigitIntegerNode(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->isInteger(index));
	assert(_tokens->getSize(index) <= 8);	
	assert(_tokens->getSize(index) >= 6);
	assert(_tokens->getSize(index) != 7);

	dateFormatFNodeOne(index);

	return;
}


bool ChronoInterpreter::timeFormatANodeOne(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->isInteger(index));
	assert(_tokens->getSize(index) < 5);
	assert(_tokens->getSize(index) > 2);
	
	int number = _tokens->getInteger(index);
	_minute = number % 100;
	_hour = number / 100;

	if(timeFormatANodeTwo(index+1)) {
		insertTime(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::timeFormatANodeTwo(int index) {
	if(!isValid24HrsTime()) {
		return false;
	} else if(_tokens->isOutOfBounds(index)) {
		return true;
	} else if(_tokens->hasMeaning("HRS", index)) {
		_tokens->remove(index);
		return true;
	} else if(_tokens->isExtensionOfAWord(index)) {
		return false;
	} else {
		return true;
	}
}


bool ChronoInterpreter::timeFormatBNodeOne(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->isInteger(index));
	assert(_tokens->getSize(index) < 5);

	int number = _tokens->getInteger(index);
	if(number < 100) {
		_hour = number;
		_minute = 0;
	} else {
		_minute = number % 100;
		_hour = number / 100;
	}

	if(timeFormatBNodeTwo(index+1)) {
		insertTime(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::timeFormatBNodeTwo(int index) {
	if(!isValid12HrsTime()) {
		return false;
	} else if(!_tokens->isOutOfBounds(index) && _tokens->hasMeaning("MERIDIEM", index)) {
		_isMeridiemTime = true;
		if(_tokens->hasMeaning("PM", index)) {
			_isPM = true;
		}
		adjustTo24HrsTime();
		_tokens->remove(index);
		return true;
	} else {
		return false;
	}
}


bool ChronoInterpreter::timeFormatCNodeOne(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->isInteger(index));
	assert(_tokens->getSize(index) < 3);

	_hour = _tokens->getInteger(index);

	if(timeFormatCNodeTwo(index+1)) {
		insertTime(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::timeFormatCNodeTwo(int index) {
	if(!_tokens->isOutOfBounds(index) && _tokens->hasMeaning("TIMEDIVIDER", index)) {
		if(timeFormatCNodeThree(index+1)) {
			_tokens->remove(index);
			return true;
		} else {
			return false;
		}
	} else {
		return false;
	}
}

bool ChronoInterpreter::timeFormatCNodeThree(int index) {
	if(_tokens->isOutOfBounds(index) || !_tokens->isInteger(index)) {
		return false;
	} else if(_tokens->getSize(index) != 2) {
		return false;
	} else if(_tokens->getSize(index) == 2) {
		_minute = _tokens->getInteger(index);
	} else {
		assert(false);
	}

	if(timeFormatCNodeFour(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::timeFormatCNodeFour(int index) {
	if(!isValid24HrsTime()) {
		return false;
	} else if(_tokens->isOutOfBounds(index)) {
		return true;
	} else if(_tokens->hasMeaning("HRS", index)) {
		_tokens->remove(index);
		return true;
	} else if(_tokens->hasMeaning("MERIDIEM", index)) {
		if(isValid12HrsTime()) {
			_isMeridiemTime = true;
			if(_tokens->hasMeaning("PM", index)) {
				_isPM = true;
			}
			adjustTo24HrsTime();
			_tokens->remove(index);
			return true;
		} else {
			return false;
		}
	} else if(_tokens->isExtensionOfAWord(index)) {
		return false;
	} else {
		return true;
	}
}


bool ChronoInterpreter::timeRangeFormatANodeOne(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->isInteger(index));
	assert(_tokens->getSize(index) < 5);
	
	int number = _tokens->getInteger(index);
	if(number < 100) {
		_hour = number;
		_minute = 0;
	} else {
		_minute = number % 100;
		_hour = number / 100;
	}

	if(!isValid24HrsTime()) {
		return false;
	} else if(timeRangeFormatANodeTwo(index + 1)) {
		insertTime(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::timeRangeFormatANodeTwo(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(!_tokens->hasMeaning("RANGE", index)) {
		return false;
	}
	int hour = _hour;
	int minute = _minute;


	if(timeRangeFormatANodeThree(index+1)) {
		if(_isMeridiemTime) {
			if(_hour > 12) {
				_hour -= 12;
			}
			if(_hour == 0) {
				_hour += 12;
			}
			if((_hour < hour) || (_hour == hour && _minute < minute)) {
				_isPM = !_isPM;
			}
			if(hour == 12) {
				_isPM = !_isPM;
			}
			if(_hour == 12) {
				_isPM = !_isPM;
			}
		} else {
			_isPM = false;
			if(hour == 0) {
				hour = 12;
			}
		}
		_hour = hour;
		_minute = minute;
		if(_isMeridiemTime && !isValid12HrsTime()) {
			return false;
		} else {
			adjustTo24HrsTime();
			_tokens->remove(index);
			return true;
		}
	} else {
		return false;
	}
}

bool ChronoInterpreter::timeRangeFormatANodeThree(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if (!_tokens->isInteger(index)) {
		return false;
	}
	int size = _tokens->getSize(index);
	if (size > 4) {
		return false;
	} else if(timeFormatBNodeOne(index)) {
		return true;
	} else if(size > 2) {
		if(timeFormatANodeOne(index)) {
			return true;
		} else {
			return false;
		}
	} else if(size < 3) {
		if(timeFormatCNodeOne(index)) {
			return true;
		} else {
			return false;
		}
	} else {
		assert(false);
		return false;
	}
}


bool ChronoInterpreter::timeRangeFormatBNodeOne(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->isInteger(index));
	assert(_tokens->getSize(index) < 3);

	_hour = _tokens->getInteger(index);

	if(timeRangeFormatBNodeTwo(index+1)) {
		insertTime(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::timeRangeFormatBNodeTwo(int index) {
	if(!_tokens->isOutOfBounds(index) && _tokens->hasMeaning("TIMEDIVIDER", index)) {
		if(timeRangeFormatBNodeThree(index+1)) {
			_tokens->remove(index);
			return true;
		} else {
			return false;
		}
	} else {
		return false;
	}
}

bool ChronoInterpreter::timeRangeFormatBNodeThree(int index) {
	if(_tokens->isOutOfBounds(index) || !_tokens->isInteger(index)) {
		return false;
	} else if(_tokens->getSize(index) != 2) {
		return false;
	}

	_minute = _tokens->getInteger(index);
	if(!isValid24HrsTime()) {
		return false;
	}

	if(timeFormatCNodeFour(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::timeRangeFormatBNodeFour(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(!_tokens->hasMeaning("RANGE", index)) {
		return false;
	}

	int hour = _hour;
	int minute = _minute;

	if(timeRangeFormatBNodeFive(index+1)) {
		if(_isMeridiemTime) {
			if(_hour > 12) {
				_hour -= 12;
			}
			if(_hour == 0) {
				_hour += 12;
			}
			if((_hour < hour) || (_hour == hour && _minute < minute)) {
				_isPM = !_isPM;
			}
			if(hour == 12) {
				_isPM = !_isPM;
			}
			if(_hour == 12) {
				_isPM = !_isPM;
			}
		} else {
			_isPM = false;
			if(hour == 0) {
				hour = 12;
			}
		}
		_hour = hour;
		_minute = minute;
		if(_isMeridiemTime && !isValid12HrsTime()) {
			return false;
		} else {
			adjustTo24HrsTime();
			_tokens->remove(index);
			return true;
		}
	} else {
		return false;
	}	
}

bool ChronoInterpreter::timeRangeFormatBNodeFive(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if (!_tokens->isInteger(index)) {
		return false;
	}
	int size = _tokens->getSize(index);
	if (size > 4) {
		return false;
	} else if(timeFormatBNodeOne(index)) {
		return true;
	} else if(size > 2) {
		if(timeFormatANodeOne(index)) {
			return true;
		} else {
			return false;
		}
	} else if(size < 3) {
		if(timeFormatCNodeOne(index)) {
			return true;
		} else {
			return false;
		}
	} else {
		assert(false);
		return false;
	}
}


bool ChronoInterpreter::dateFormatANodeOne(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->isInteger(index));
	assert(_tokens->getSize(index) < 3);

	_day = _tokens->getInteger(index);
	if(dateFormatANodeTwo(index+1)) {
		insertDate(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::dateFormatANodeTwo(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(isDaySuffix(index) && dateFormatANodeThree(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return dateFormatANodeThree(index);
	}
}

bool ChronoInterpreter::dateFormatANodeThree(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(_tokens->hasMeaning("DATEDIVIDER", index) && dateFormatANodeFour(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::dateFormatANodeFour(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(_tokens->isInteger(index) && _tokens->getSize(index) <= 2) {
		_month = _tokens->getInteger(index);
	} else if (_tokens->hasMeaning("MONTHSOFTHEYEAR", index)) {
		_month = getMonthFromWord(index);
	} else {
		return false;
	}

	if(dateFormatANodeFive(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::dateFormatANodeFive(int index) {
	if(_tokens->isOutOfBounds(index)) {
		_year = inferYear();
	} else if(_tokens->hasMeaning("DATEDIVIDER", index)) {
		if(dateFormatANodeSix(index+1)) {
			_tokens->remove(index);
			return true;
		} else {
			return false;
		}
	} else {
		_year = inferYear();
	}

	if(isValidDate()) {
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::dateFormatANodeSix(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	}

	unsigned int size = _tokens->getSize(index);
	if(_tokens->isInteger(index) && (size == 4 || size == 2)) {
		if(size == 2) {
			_year = inferYear(_tokens->getInteger(index));
		} else if(size == 4) {
			_year = _tokens->getInteger(index);
		}
	} else {
		return false;
	}
	
	if(isValidDate()) {
		_tokens->remove(index);
		return true;
	} else {
		return false;
	}
}


bool ChronoInterpreter::dateFormatBNodeOne(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->hasMeaning("MONTHSOFTHEYEAR", index));

	_month = getMonthFromWord(index);
	
	if(dateFormatBNodeTwo(index+1)) {
		insertDate(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::dateFormatBNodeTwo(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(_tokens->hasMeaning("DATEDIVIDER", index) && dateFormatBNodeThree(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::dateFormatBNodeThree(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(_tokens->isInteger(index) && _tokens->getSize(index) <= 2) {
		_day = _tokens->getInteger(index);
	} else {
		return false;
	}

	if(dateFormatBNodeFour(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::dateFormatBNodeFour(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return dateFormatBNodeFive(index);
	} else if(isDaySuffix(index) && dateFormatBNodeFive(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return dateFormatBNodeFive(index);
	}
}

bool ChronoInterpreter::dateFormatBNodeFive(int index) {
	if(_tokens->isOutOfBounds(index)) {
		_year = inferYear();
	} else if(_tokens->hasMeaning("DATEDIVIDER", index)) {
		if(dateFormatBNodeSix(index+1)) {
			_tokens->remove(index);
			return true;
		} else {
			return false;
		}
	} else {
		_year = inferYear();
	}

	if(isValidDate()) {
		dateRangeFormatBNodeOne(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::dateFormatBNodeSix(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	}

	unsigned int size = _tokens->getSize(index);
	if(_tokens->isInteger(index) && (size == 4 || size == 2)) {
		if(size == 2) {
			_year = inferYear(_tokens->getInteger(index));
		} else if(size == 4){
			_year = _tokens->getInteger(index);
		}
	} else {
		return false;
	}
	
	if(isValidDate()) {
		_tokens->remove(index);
		return true;
	} else {
		return false;
	}
}


bool ChronoInterpreter::dateFormatCNodeOne(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->hasMeaning("MONTHSOFTHEYEAR", index));
	
	_month = getMonthFromWord(index);
	
	if(dateFormatCNodeTwo(index+1)) {
		insertDate(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::dateFormatCNodeTwo(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(_tokens->isInteger(index) && _tokens->getSize(index) <= 2) {
		_day = _tokens->getInteger(index);
	} else {
		return false;
	}

	if(dateFormatCNodeThree(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::dateFormatCNodeThree(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return dateFormatCNodeFour(index);
	} else if(isDaySuffix(index) && dateFormatCNodeFour(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return dateFormatCNodeFour(index);
	}
}

bool ChronoInterpreter::dateFormatCNodeFour(int index) {
	bool yearFound = false;
	
	if(_tokens->isOutOfBounds(index)) {
		_year = inferYear();
	} else if(isYear(index)) {
		yearFound = true;
		_year=_tokens->getInteger(index);
		if(_year < 100) {
			_year = inferYear(_year);
		}
	} else {
		_year = inferYear();
	}

	if(isValidDate()) {
		if(yearFound) {
			_tokens->remove(index);
		} else {
			dateRangeFormatBNodeOne(index);
		}
		return true;
	} else {
		return false;
	}
}


bool ChronoInterpreter::dateFormatDNodeOne(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->isInteger(index));
	assert(_tokens->getSize(index) < 3);

	_day = _tokens->getInteger(index);

	if(dateFormatDNodeTwo(index+1)) {
		insertDate(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::dateFormatDNodeTwo(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(isDaySuffix(index) && dateFormatDNodeThree(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return dateFormatDNodeThree(index);
	}
}

bool ChronoInterpreter::dateFormatDNodeThree(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(_tokens->hasMeaning("MONTHSOFTHEYEAR", index)) {
		_month = getMonthFromWord(index);
	} else {
		return false;
	}
		
	if(dateFormatDNodeFour(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::dateFormatDNodeFour(int index) {
	bool yearFound = false;
	
	if(_tokens->isOutOfBounds(index)) {
		_year = inferYear();
	} else if(isYear(index)) {
		yearFound = true;
		_year=_tokens->getInteger(index);
		if(_year < 100) {
			_year = inferYear(_year);
		}
	} else {
		_year = inferYear();
	}

	if(isValidDate()) {
		if(yearFound) {
			_tokens->remove(index);
		}
		return true;
	} else {
		return false;
	}
}


bool ChronoInterpreter::dateFormatENodeOne(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->hasMeaning("THIS", index));

	if(dateFormatENodeFour(index+1)) {
		_tokens->remove(index);
		return true;
	}

	return false;
}

bool ChronoInterpreter::dateFormatENodeTwo(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(_tokens->hasMeaning("NEXT", index)) {
		_nextCount++;
		if(dateFormatENodeTwo(index+1)) {
			_tokens->remove(index);
			return true;
		} else {
			return false;
		}
	} else {
		return dateFormatENodeFour(index);
	}
}

bool ChronoInterpreter::dateFormatENodeThree(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	}

	if(_tokens->hasMeaning("RELATIONALDATE", index)) {
		int daysToTarget = getRelationalDateFromWord(index);
		int date = ADD_TO_DATE(daysToTarget, DATE);
		_day = GET_DAY(date);
		_month = GET_MONTH(date);
		_year = GET_YEAR(date);
		if(isValidDate()) {
			insertDate(index);
			return true;
		} else {
			return false;
		}
	} else {
		return dateFormatENodeThree(index);
	}
}

bool ChronoInterpreter::dateFormatENodeFour(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	}

	if(_tokens->hasMeaning("WEEK", index)) {
		int daysToTarget = 7 - WEEK_DAY;
		if(daysToTarget == 0 && _nextCount == 0) {
			daysToTarget += 7;
		}
		daysToTarget += 7 * _nextCount;
		int date = ADD_TO_DATE(daysToTarget, DATE);
		_day = GET_DAY(date);
		_month = GET_MONTH(date);
		_year = GET_YEAR(date);
		if(isValidDate()) {
			insertDate(index);
			return true;
		} else {
			return false;
		}
	} else {
		return dateFormatENodeFive(index);
	}
}

bool ChronoInterpreter::dateFormatENodeFive(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	}

	if(_tokens->hasMeaning("DAYSOFTHEWEEK", index)) {
		int daysToTarget = getDayOfWeekFromWord(index);

		daysToTarget = (daysToTarget + 7 - WEEK_DAY) % 7;
		if(daysToTarget == 0 && _nextCount == 0) {
			daysToTarget += 7;
		}
		daysToTarget += 7 * _nextCount;
		int date = ADD_TO_DATE(daysToTarget, DATE);
		_day = GET_DAY(date);
		_month = GET_MONTH(date);
		_year = GET_YEAR(date);
		if(isValidDate()) {
			insertDate(index);
			return true;
		} else {
			return false;
		}
	} else {
		return false;
	}
}


bool ChronoInterpreter::dateFormatFNodeOne(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->isInteger(index));
	int size = _tokens->getSize(index);	
	assert(size == 8 || size == 6);

	int number = _tokens->getInteger(index);
	if(size == 6) {
		_year = inferYear(number % 100);
		number /= 100;
	} else if(size == 8) {
		_year = number % 10000;
		number /= 10000;
	} else {
		return false;
	}
	_month = number % 100;
	_day = number/100;

	if(isValidDate()) {
		insertDate(index);
		return true;
	} else {
		return false;
	}
}


bool ChronoInterpreter::dateRangeFormatANodeOne(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->isInteger(index));
	assert(_tokens->getSize(index) < 3);
	
	_day = _tokens->getInteger(index);
	if(dateRangeFormatANodeTwo(index + 1)) {
		insertDate(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::dateRangeFormatANodeTwo(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	}

	if(isDaySuffix(index) && dateRangeFormatANodeThree(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return dateRangeFormatANodeThree(index);
	}
}

bool ChronoInterpreter::dateRangeFormatANodeThree(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(!_tokens->hasMeaning("RANGE", index)) {
		return false;
	}

	if(dateRangeFormatANodeFour(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::dateRangeFormatANodeFour(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if (!_tokens->isInteger(index)) {
		return false;
	} else if(_tokens->getSize(index) > 4) {
		return dateRangeFormatANodeFive(index);
	}
	
	int size = _tokens->getSize(index);
	if(timeFormatBNodeOne(index)) {
		return dateRangeFormatANodeFive(index+1);
	} else if(size > 2) {
		if(timeFormatANodeOne(index)) {
			return dateRangeFormatANodeFive(index+1);
		} else {
			return dateRangeFormatANodeFive(index);
		}
	} else if(size < 3) {
		if(timeFormatCNodeOne(index)) {
			return dateRangeFormatANodeFive(index+1);
		} else {
			return dateRangeFormatANodeFive(index);
		}
	} else {
		assert(false);
		return false;
	}
}

bool ChronoInterpreter::dateRangeFormatANodeFive(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(!_tokens->isInteger(index)) {
		return false;
	}
	int day = _day;
	int size = _tokens->getSize(index);
	if(size < 3) {
		if(dateFormatANodeOne(index) ||
		   dateFormatDNodeOne(index)) {
			_day = day;
			if(isValidDate()) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	} else if(size == 6 || size == 8) {
		if(dateFormatFNodeOne(index)) {
			_day = day;
			if(isValidDate()) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	} else {
		return false;
	}
}


bool ChronoInterpreter::dateRangeFormatBNodeOne(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if (!_tokens->isInteger(index)) {
		return dateRangeFormatBNodeTwo(index);
	} else if(_tokens->getSize(index) > 4) {
		return dateRangeFormatBNodeTwo(index);
	}
	
	int size = _tokens->getSize(index);
	if(timeFormatBNodeOne(index)) {
		return dateRangeFormatBNodeTwo(index+1);
	} else if(size > 2) {
		if(timeFormatANodeOne(index)) {
			return dateRangeFormatBNodeTwo(index+1);
		} else {
			return dateRangeFormatBNodeTwo(index);
		}
	} else if(size < 3) {
		if(timeFormatCNodeOne(index)) {
			return dateRangeFormatBNodeTwo(index+1);
		} else {
			return dateRangeFormatBNodeTwo(index);
		}
	} else {
		assert(false);
		return false;
	}
}

bool ChronoInterpreter::dateRangeFormatBNodeTwo(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(!_tokens->hasMeaning("RANGE", index)) {
		return false;
	} else if(dateRangeFormatBNodeThree(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::dateRangeFormatBNodeThree(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if (!_tokens->isInteger(index)) {
		return false;
	} else if (_tokens->getSize(index) > 2) {
		return false;
	}
	
	int previousDay = _day;
	_day = _tokens->getInteger(index);
	if(isValidDate()) {
		dateRangeFormatBNodeFour(index+1);
		insertDate(index);
		_day = previousDay;
		return true;
	} else {
		_day = previousDay;
		return false;
	}
}

bool ChronoInterpreter::dateRangeFormatBNodeFour(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(isDaySuffix(index)) {
		_tokens->remove(index);
		return true;
	} else {
		return false;
	}
}


bool ChronoInterpreter::naturalLanguageNodeOne(int index) {
	assert(!_tokens->isOutOfBounds(index));

	if(naturalLanguageNodeTwo(index+1)) {
		_tokens->remove(index);
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::naturalLanguageNodeTwo(int index) {
	if(_tokens->isOutOfBounds(index)) {
		return false;
	} else if(_tokens->isMarkedAs(DATE_MARKER, index) ||
			  _tokens->isMarkedAs(TIME_MARKER, index)) {
		return true;
	} else {
		return false;
	}
}


int ChronoInterpreter::getMonthFromWord(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->hasMeaning("MONTHSOFTHEYEAR", index));

	if(_tokens->hasMeaning("JANUARY", index)) {
		return 1;
	} else if(_tokens->hasMeaning("FEBRUARY", index)) {
		return 2;
	} else if(_tokens->hasMeaning("MARCH", index)) {
		return 3;
	} else if(_tokens->hasMeaning("APRIL", index)) {
		return 4;
	} else if(_tokens->hasMeaning("MAY", index)) {
		return 5;
	} else if(_tokens->hasMeaning("JUNE", index)) {
		return 6;
	} else if(_tokens->hasMeaning("JULY", index)) {
		return 7;
	} else if(_tokens->hasMeaning("AUGUST", index)) {
		return 8;
	} else if(_tokens->hasMeaning("SEPTEMBER", index)) {
		return 9;
	} else if(_tokens->hasMeaning("OCTOBER", index)) {
		return 10;
	} else if(_tokens->hasMeaning("NOVEMBER", index)) {
		return 11;
	} else if(_tokens->hasMeaning("DECEMBER", index)) {
		return 12;
	}
	
	assert(false); //method should return before reaching this line
	return -1;
}

int ChronoInterpreter::getDayOfWeekFromWord(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->hasMeaning("DAYSOFTHEWEEK", index));

	if(_tokens->hasMeaning("MONDAY", index)) {
		return 1;
	} else if(_tokens->hasMeaning("TUESDAY", index)) {
		return 2;
	} else if(_tokens->hasMeaning("WEDNESDAY", index)) {
		return 3;
	} else if(_tokens->hasMeaning("THURSDAY", index)) {
		return 4;
	} else if(_tokens->hasMeaning("FRIDAY", index)) {
		return 5;
	} else if(_tokens->hasMeaning("SATURDAY", index)) {
		return 6;
	} else if(_tokens->hasMeaning("SUNDAY", index)) {
		return 7;
	}
	
	assert(false); //method should return before reaching this line
	return -1;
}

int ChronoInterpreter::getRelationalDateFromWord(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->hasMeaning("RELATIONALDATE", index));

	if(_tokens->hasMeaning("TODAY", index)) {
		return 0;
	} else if(_tokens->hasMeaning("TOMORROW", index)) {
		return 1;
	} else if(_tokens->hasMeaning("YESTERDAY", index)) {
		return -1;
	}
	
	assert(false); //method should return before reaching this line
	return -1;
}


void ChronoInterpreter::insertTime(int index) {
	int time = GENERATE_TIME(_hour, _minute);
	_tokens->markAs(TIME_MARKER, to_string(time), index);
	_time = time;
	_timeCount++;
	
	return;
}

void ChronoInterpreter::insertDate(int index) {
	int date = GENERATE_DATE(_day, _month, _year);
	_tokens->markAs(DATE_MARKER, to_string(date), index);
	_date = date;
	_dateCount++;
	
	return;
}


void ChronoInterpreter::adjustTo24HrsTime() {
	if(_isPM && _hour != 12) {
			_hour+=12;
	} else if(!_isPM && _hour == 12) {
			_hour = 0;
	}

	return;
}

int ChronoInterpreter::inferYear() {
	int year = DATE_YEAR;
	if(DATE_MONTH + 6 > 12 && (DATE_MONTH + 6) % 12 > _month) {
		year++;
	}

	return year;
}

int ChronoInterpreter::inferYear(int twoDigitYear) {
	int year = twoDigitYear + 2000;
	while (DATE_YEAR - 5 > year) {
		year += 100;
	}

	return year;
}


bool ChronoInterpreter::isValid24HrsTime() {
	if (_hour >= 24 || _hour < 0) {
		return false;
	}
	return isValidMinutes();
}

bool ChronoInterpreter::isValid12HrsTime() {
	if (_hour > 12 || _hour <= 0) {
		return false;
	}
	return isValidMinutes();
}

bool ChronoInterpreter::isValidMinutes() {
	if(_minute >= 60 || _minute < 0) {
		return false;
	}
	return true;
}

bool ChronoInterpreter::isValidDate() {
	int daysInEachMonth[13] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	
	if(_month > 12 || _month < 1) {									//month not possible
		return false;
	} else if(_day > daysInEachMonth[_month] || _day < 1) {			//day exceed the month's limit
		return false;
	} else if((_month == 2 && _day == 29) && (!isLeap(_year))) {	//leap day not in a leap year
		return false;
	} else {
		return true;								
	}
}

bool ChronoInterpreter::isLeap(int year) {
	if(year % 400 == 0 || (year % 100 != 0 && year % 4 == 0)) {
		return true;
	} else {
		return false;
	}
}

bool ChronoInterpreter::isYear(int index) {
	assert(!_tokens->isOutOfBounds(index));

	if(!_tokens->isInteger(index)) {
		return false;
	} else if(_tokens->getSize(index) != 4 && _tokens->getSize(index) != 2) {
		return false;
	} else if(_tokens->isExtensionOfAWord(index)) {
		return true;
	} else if(_tokens->getSize(index) == 4) {
		return false;
	} else if(_tokens->isOutOfBounds(index+1)) {
		return true;
	} else if(_tokens->hasMeaning("MERIDIEM", index+1) ||
	   _tokens->hasMeaning("MONTHSOFTHEYEAR", index+1) ||
	   _tokens->hasMeaning("DATEDIVIDER", index+1)) {
		return false;
	} else {
		return true;
	}
}

bool ChronoInterpreter::isDaySuffix(int index) {
	assert(!_tokens->isOutOfBounds(index));

	if(_day > 3 && _day < 21 && _tokens->hasMeaning("FOURTH", index)) {
		return true;
	} else if(_day > 23 && _day < 31 && _tokens->hasMeaning("FOURTH", index)) {
		return true;
	} else if(_day % 10 == 1 && _tokens->hasMeaning("FIRST", index)) {
		return true;
	} else if(_day%10 == 2 && _tokens->hasMeaning("SECOND", index)) {
		return true;
	} else if(_day%10 == 3 && _tokens->hasMeaning("THIRD", index)) {
		return true;
	} else {
		return false;
	}
}


void ChronoInterpreter::clearCache() {
	_nextCount = NO_VALUE;
	_isPM = false;
	_isMeridiemTime = false;

	return;
}
```
###### doMe\ChronoInterpreter.h
``` h

#pragma once

#include "InputTokens.h"
#include "Commons.h"
#include <assert.h>
#include <time.h>

#define NO_VALUE 0
#define TIME_MARKER "time"
#define DATE_MARKER "date"

class ChronoInterpreter
{
public:
	~ChronoInterpreter(void);
	static ChronoInterpreter* getInstance();
	void interpretDateAndTime(InputTokens* tokens, int index);
	int dateArithmetics(int days, int date);

private:
	ChronoInterpreter();
	static ChronoInterpreter* _theOne;

	InputTokens* _tokens;
	Commons* common;
	int _day;
	int _month;
	int _year;
	int _hour;
	int _minute;
	int _nextCount;
	bool _isPM;
	bool _isMeridiemTime;
	int _dateCount;
	int _date;
	int _timeCount;
	int _time;

	void setEnvironment(InputTokens* tokens);
	void traverseTokensForIntepretation(int index);
	void removeNaturalLanguageTokens(int index);

	void interpretationNode(int index);
	void integerNode(int index);
	void alphabeticMonthNode(int index);
	void thisNode(int index);
	void nextNode(int index);
	void relationalDateNode(int index);
	void dayOfTheWeekNode(int index);
	void naturalLanguageNode(int index);

	void twoDigitIntegerNode(int index);
	void threeDigitIntegerNode(int index);
	void fourDigitIntegerNode(int index);
	void sixDigitIntegerNode(int index);
	
	//following nodes look at an aspect of each chrono format
	//the area in the [] brackets is the part being checked by the node
	bool timeFormatANodeOne(int index);			//[1330]hrs
	bool timeFormatANodeTwo(int index);			//1330[hrs]

	bool timeFormatBNodeOne(int index);			//[1230]pm
	bool timeFormatBNodeTwo(int index);			//1230[pm]
	
	bool timeFormatCNodeOne(int index);			//[8].00pm
	bool timeFormatCNodeTwo(int index);			//8[.]00pm
	bool timeFormatCNodeThree(int index);		//8.[00]pm
	bool timeFormatCNodeFour(int index);		//8.00[pm]

	bool timeRangeFormatANodeOne(int index);	//[8]-10pm
	bool timeRangeFormatANodeTwo(int index);	//8[-]10pm
	bool timeRangeFormatANodeThree(int index);	//8-[10pm]

	bool timeRangeFormatBNodeOne(int index);	//[8].00-10pm
	bool timeRangeFormatBNodeTwo(int index);	//8[.]00-10pm
	bool timeRangeFormatBNodeThree(int index);	//8.[00]-10pm
	bool timeRangeFormatBNodeFour(int index);	//8.00[-]10pm
	bool timeRangeFormatBNodeFive(int index);	//8.00-[10pm]

	bool dateFormatANodeOne(int index);			//[1]st/2/17
	bool dateFormatANodeTwo(int index);			//1[st]/2/17
	bool dateFormatANodeThree(int index);		//1st[/]2/17
	bool dateFormatANodeFour(int index);		//1st/[2]/17
	bool dateFormatANodeFive(int index);		//1st/2[/]17
	bool dateFormatANodeSix(int index);			//1st/2/[17]

	bool dateFormatBNodeOne(int index);			//[feb]/1st/17
	bool dateFormatBNodeTwo(int index);			//feb[/]1st/17
	bool dateFormatBNodeThree(int index);		//feb/[1]st/17
	bool dateFormatBNodeFour(int index);		//feb/1[st]/17
	bool dateFormatBNodeFive(int index);		//feb/1st[/]17
	bool dateFormatBNodeSix(int index);			//feb/1st/[17]

	bool dateFormatCNodeOne(int index);			//[feb]1st2017
	bool dateFormatCNodeTwo(int index);			//feb[1]st2017
	bool dateFormatCNodeThree(int index);		//feb1[st]2017
	bool dateFormatCNodeFour(int index);		//feb1st[2017]

	bool dateFormatDNodeOne(int index);			//[1]stfeb2017
	bool dateFormatDNodeTwo(int index);			//1[st]feb2017
	bool dateFormatDNodeThree(int index);		//1st[feb]2017
	bool dateFormatDNodeFour(int index);		//1stfeb[2017]

	bool dateFormatENodeOne(int index);			//[this] week
	bool dateFormatENodeTwo(int index);			//[next next next] sun
	bool dateFormatENodeThree(int index);		//[tmr]
	bool dateFormatENodeFour(int index);		//next next next [week]
	bool dateFormatENodeFive(int index);		//this [mon]

	bool dateFormatFNodeOne(int index);			//[12032017]

	bool dateRangeFormatANodeOne(int index);	// 800 [1]st to 10am 2nd feb
	bool dateRangeFormatANodeTwo(int index);	// 800 1[st] to 10am 2nd feb
	bool dateRangeFormatANodeThree(int index);	// 800 1st [to] 10am 2nd feb
	bool dateRangeFormatANodeFour(int index);	// 800 1st to [10am] 2nd feb
	bool dateRangeFormatANodeFive(int index);	// 800 1st to 10am [2nd feb]

	bool dateRangeFormatBNodeOne(int index);	//feb 2nd [2pm] to 1st 800hrs 
	bool dateRangeFormatBNodeTwo(int index);	//feb 2nd 2pm [to] 1st 800hrs 
	bool dateRangeFormatBNodeThree(int index);	//feb 2nd 2pm to [1]st 800hrs 
	bool dateRangeFormatBNodeFour(int index);	//feb 2nd 2pm to 1[st] 800hrs 

	bool naturalLanguageNodeOne(int index);		//[by] tmr
	bool naturalLanguageNodeTwo(int index);		//by [tmr]
	
	int getMonthFromWord(int index);	
	int getDayOfWeekFromWord(int index);
	int getRelationalDateFromWord(int index);

	void insertTime(int index);
	void insertDate(int index);

	void adjustTo24HrsTime();
	int inferYear();
	int inferYear(int twoDigitYear);

	bool isValid24HrsTime();
	bool isValid12HrsTime();
	bool isValidMinutes();
	bool isValidDate();
	bool isLeap(int year);
	bool isYear(int index);
	bool isDaySuffix(int index);

	void clearCache();
};
```
###### doMe\CommandPacker.cpp
``` cpp

#include "CommandPacker.h"

CommandPacker* CommandPacker::_theOne = NULL;

CommandPacker::CommandPacker() {
	_taskPacker = TaskPacker::getInstance();
	_indexes = new vector<int>;
}

CommandPacker::~CommandPacker(void) {
}

CommandPacker* CommandPacker::getInstance() {
	if(_theOne == NULL) {
		_theOne = new CommandPacker;
	}

	return _theOne;
}


Command* CommandPacker::packCommand(InputTokens* tokens) {
	assert(tokens);

	setEnvironment(tokens);
	branchToNode(START_INDEX);

	return _command;
}


void CommandPacker::setEnvironment(InputTokens* tokens) {
	assert(tokens);

	_tokens = tokens;
	_description = NO_STRING;
	_singleIndex = NO_VALUE;
	delete _indexes;
	_indexes = new vector<int>;
	_isDeleteDate = false;
	_isDeleteTime = false;
	_isDeleteLocation = false;

	return;
}

void CommandPacker::branchToNode(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->hasMeaning("DISPLAY", index)) {
		nodeOneOfDisplayCommand(index+1);
	} else if(_tokens->hasMeaning("EDIT", index)) {
		nodeOneOfChangeDirectoryCommand(index+1);
	} else if(_tokens->hasMeaning("DEL", index)) {
		nodeOneOfDeleteCommand(index+1);
	} else if(_tokens->hasMeaning("UNDO", index)) {
		nodeOneOfUndoCommand(index+1);
	} else if(_tokens->hasMeaning("REDO", index)) {
		nodeOneOfRedoCommand(index+1);
	} else if(_tokens->hasMeaning("HELP", index)) {
		nodeOneOfHelpCommand(index+1);
	} else if(_tokens->hasMeaning("EXIT", index)) {
		nodeOneOfExitCommand(index+1);
	} else if(_tokens->hasMeaning("SCROLL", index)) {
		nodeOneOfScrollCommand(index+1);
	} else if(_tokens->hasMeaning("MARK", index)) {
		nodeOneOfMarkCommand(index+1);
	} else if(_tokens->hasMeaning("ADD", index)) {
		nodeTwoOfAddCommand(index+1);	
	} else if(_tokens->hasMeaning("SEARCH", index)) {
		nodeOneOfSearchCommand(index+1);
	} else if(_tokens->hasMeaning("CLEAR", index)) {
		nodeOneOfClearCommand(index+1);
	} else if(_tokens->hasMeaning("CHANGEDIRECTORY", index)) {
		nodeThreeOfChangeDirectoryCommand(index+1);
	} else if(_tokens->hasMeaning("DONE", index)) {
		nodeSevenOfMarkCommand(index);
	} else if(_tokens->hasMeaning("UNDONE", index)) {
		nodeSevenOfMarkCommand(index);
	} else if(_tokens->hasMeaning("NOT", index)) {
		nodeSevenOfMarkCommand(index);
	} else if(_tokens->hasMeaning("CHANGEVIEWTYPE", index)) {
		nodeTwoOfChangeViewTypeCommand(index+1);
	} else if(_tokens->isInteger(index)) {
		nodeOneOfMarkCommand(index);
	} else {
		nodeOneOfAddCommand(index);
	}
	
	return;
}


void CommandPacker::nodeOneOfDisplayCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packDisplayCommand();
	} else {
		nodeTwoOfChangeViewTypeCommand(index);
	}

	return;
}


void CommandPacker::nodeOneOfChangeDirectoryCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->hasMeaning("THE", index)) {
		nodeTwoOfChangeDirectoryCommand(index+1);
	} else {
		nodeTwoOfChangeDirectoryCommand(index);
	}

	return;
}

void CommandPacker::nodeTwoOfChangeDirectoryCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->hasMeaning("DIRECTORY", index)) {
		nodeThreeOfChangeDirectoryCommand(index+1);
	} else {
		nodeOneOfChangeViewTypeCommand(index);
	}

	return;
}

void CommandPacker::nodeThreeOfChangeDirectoryCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		_description = NO_STRING;
		packChangeDirectoryCommand();
	} else if(_tokens->hasMeaning("TO", index)) {
		nodeFourOfChangeDirectoryCommand(index+1);
	} else {
		nodeFourOfChangeDirectoryCommand(index);
	}

	return;
}

void CommandPacker::nodeFourOfChangeDirectoryCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else {
		extractTerm(index);
		packChangeDirectoryCommand();
	}
	
	return;
}


void CommandPacker::nodeOneOfChangeViewTypeCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->hasMeaning("VIEW", index)) {
		nodeTwoOfChangeViewTypeCommand(index+1);
	} else {
		nodeOneOfEditCommand(SECOND_INDEX);
	}
	
	return;
}

void CommandPacker::nodeTwoOfChangeViewTypeCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->hasMeaning("TO", index)) {
		nodeThreeOfChangeViewTypeCommand(index+1);
	} else {
		nodeThreeOfChangeViewTypeCommand(index);
	}

	return;
}

void CommandPacker::nodeThreeOfChangeViewTypeCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->isInteger(index)) {
		_singleIndex = stoi(_tokens->getToken(index));
		nodeFourOfChangeViewTypeCommand(index+1);
	} else if(_tokens->hasMeaning("VIEWDESCRIPTION", index)) {
		extractViewType(index);
		nodeFourOfChangeViewTypeCommand(index+1);
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}

void CommandPacker::nodeFourOfChangeViewTypeCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packChangeViewTypeCommand();
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}


void CommandPacker::nodeOneOfDeleteCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		_singleIndex = LAST_INDEX;
		packDeleteCommand();
	} else if(_tokens->isInteger(index)) {
		_singleIndex = stoi(_tokens->getToken(index));
		nodeTwoOfDeleteCommand(index+1);
	} else if(_tokens->hasMeaning("LAST", index)) {
		_singleIndex = LAST_INDEX;
		nodeTwoOfDeleteCommand(index+1);
	} else {
		_singleIndex = LAST_INDEX;
		nodeTwoOfDeleteCommand(index);
	}
	
	return;
}

void CommandPacker::nodeTwoOfDeleteCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packDeleteCommand();
	} else if(_tokens->hasMeaning("DELETEPARAMETER", index)) {
		nodeThreeOfDeleteCommand(index);
	} else {
		nodeOneOfClearCommand(SECOND_INDEX);
	}
	
	return;
}

void CommandPacker::nodeThreeOfDeleteCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		addToIndexes(_singleIndex);
		packDeleteTaskParametersCommand();
	} else if(_tokens->hasMeaning("DELETEPARAMETER", index)) {
		extractDeleteParameter(index);
		nodeThreeOfDeleteCommand(index+1);
	} else {
		nodeOneOfClearCommand(SECOND_INDEX);
	}
	
	return;
}


void CommandPacker::nodeOneOfUndoCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packUndoCommand();
	} else if(_tokens->hasMeaning("LAST", index)) {
		nodeTwoOfUndoCommand(index+1);
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}

void CommandPacker::nodeTwoOfUndoCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packUndoCommand();
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}


void CommandPacker::nodeOneOfRedoCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packRedoCommand();
	} else if(_tokens->hasMeaning("LAST", index)) {
		nodeTwoOfRedoCommand(index+1);
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}

void CommandPacker::nodeTwoOfRedoCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packRedoCommand();
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}


void CommandPacker::nodeOneOfHelpCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packHelpCommand();
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}


void CommandPacker::nodeOneOfExitCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packExitCommand();
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}


void CommandPacker::nodeOneOfScrollCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packScrollCommand();
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}


void CommandPacker::nodeOneOfClearCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packClearCommand();
	} else {
		nodeTwoOfClearCommand(index);
	}
	
	return;
}

void CommandPacker::nodeTwoOfClearCommand(int index) {
	assert(!_tokens->isOutOfBounds(index));

	if(_tokens->hasMeaning("ALL", index)) {
		nodeThreeOfClearCommand(index+1);
	} else {
		nodeFourOfClearCommand(index);
	}
	
	return;
}

void CommandPacker::nodeThreeOfClearCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packClearCommand();
	} else if(_tokens->hasMeaning("DELETEPARAMETER", index)) {
		nodeSevenOfClearCommand(index);
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}

	return;
}

void CommandPacker::nodeFourOfClearCommand(int index) {
	assert(!_tokens->isOutOfBounds(index));
	
	if(_tokens->isInteger(index)) {
		addToIndexes(_tokens->getInteger(index));
		nodeFiveOfClearCommand(index+1);
	} else if(_tokens->hasMeaning("DELETEPARAMETER", index)) {
		nodeSevenOfClearCommand(index);
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}

void CommandPacker::nodeFiveOfClearCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packClearCommand();
	} else if(_tokens->isInteger(index)) {
		addToIndexes(_tokens->getInteger(index));
		nodeFiveOfClearCommand(index+1);
	} else if(_tokens->hasMeaning("TO", index)) {
		nodeSixOfClearCommand(index+1);
	} else if(_tokens->hasMeaning("DELETEPARAMETER", index)) {
		nodeSevenOfClearCommand(index);
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}

void CommandPacker::nodeSixOfClearCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->isInteger(index)) {
		addRangeToIndexes(_tokens->getInteger(index));
		nodeFiveOfClearCommand(index+1);
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}

void CommandPacker::nodeSevenOfClearCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packDeleteTaskParametersCommand();
	} else if(_tokens->hasMeaning("DELETEPARAMETER", index)) {
		extractDeleteParameter(index);
		nodeThreeOfDeleteCommand(index+1);
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}


void CommandPacker::nodeOneOfSearchCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->hasMeaning("FOR", index)) {
		nodeTwoOfSearchCommand(index+1);
	} else {
		nodeTwoOfSearchCommand(index);
	}

	return;
}

void CommandPacker::nodeTwoOfSearchCommand(int index) {
	if(_tokens->hasNoMoreWord(index)) {
		packInvalidCommand();
	} else {
		extractTerm(index);
		packSearchCommand();
	}
	
	return;
}


void CommandPacker::nodeOneOfMarkCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->isInteger(index)) {
		nodeTwoOfMarkCommand(index);
	} else if(_tokens->hasMeaning("LAST", index)) {
		addToIndexes(LAST_INDEX);
		nodeFourOfMarkCommand(index);
	} else if(_tokens->hasMeaning("ALL", index)) {
		nodeFourOfMarkCommand(index);
	} else {
		nodeSixOfMarkCommand(index);
	}
	
	return;
}

void CommandPacker::nodeTwoOfMarkCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->isInteger(index)) {
		addToIndexes(_tokens->getInteger(index));
		nodeTwoOfMarkCommand(index+1);
	} else if(_tokens->hasMeaning("TO", index)) {
		nodeThreeOfMarkCommand(index+1);
	} else {
		nodeFourOfMarkCommand(index);
	}
	
	return;
}

void CommandPacker::nodeThreeOfMarkCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->isInteger(index)) {
		addRangeToIndexes(_tokens->getInteger(index));
		nodeTwoOfMarkCommand(index+1);
	} else {
		nodeFourOfMarkCommand(index);
	}
	
	return;
}

void CommandPacker::nodeFourOfMarkCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->hasMeaning("DONE", index)) {
		_doneStatus = 1;
		nodeTwelveOfMarkCommand(index+1);
	} else if(_tokens->hasMeaning("UNDONE", index)) {
		_doneStatus = 0;
		nodeTwelveOfMarkCommand(index+1);
	} else if(_tokens->hasMeaning("NOT", index)) {
		nodeFiveOfMarkCommand(index+1);
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}

void CommandPacker::nodeFiveOfMarkCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->hasMeaning("DONE", index)) {
		_doneStatus = 0;
		nodeTwelveOfMarkCommand(index+1);
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}

void CommandPacker::nodeSixOfMarkCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->hasMeaning("TO", index)) {
		nodeSevenOfMarkCommand(index+1);
	} else {
		nodeSevenOfMarkCommand(index);
	}

	return;
}

void CommandPacker::nodeSevenOfMarkCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->hasMeaning("DONE", index)) {
		_doneStatus = 1;
		nodeNineOfMarkCommand(index+1);
	} else if(_tokens->hasMeaning("UNDONE", index)) {
		_doneStatus = 0;
		nodeNineOfMarkCommand(index+1);
	} else if(_tokens->hasMeaning("NOT", index)) {
		nodeEightOfMarkCommand(index+1);
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}

void CommandPacker::nodeEightOfMarkCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->hasMeaning("DONE", index)) {
		_doneStatus = 0;
		nodeNineOfMarkCommand(index+1);
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}

void CommandPacker::nodeNineOfMarkCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		addToIndexes(LAST_INDEX);
		packMarkCommand();
	} else if(_tokens->hasMeaning("ALL", index)) {
		packMarkCommand();
	} else if(_tokens->hasMeaning("LAST", index)) {
		addToIndexes(LAST_INDEX);
		packMarkCommand();
	} else if(_tokens->isInteger(index)) {
		nodeTenOfMarkCommand(index);
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}

void CommandPacker::nodeTenOfMarkCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packMarkCommand();
	} else if(_tokens->isInteger(index)) {
		addToIndexes(_tokens->getInteger(index));
		nodeTenOfMarkCommand(index+1);
	} else if(_tokens->hasMeaning("TO", index)) {
		nodeElevenOfMarkCommand(index+1);
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}

void CommandPacker::nodeElevenOfMarkCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->isInteger(index)) {
		addRangeToIndexes(_tokens->getInteger(index));
		nodeTenOfMarkCommand(index+1);
	} else {
		nodeOneOfAddCommand(index);
	}
	
	return;
}

void CommandPacker::nodeTwelveOfMarkCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packMarkCommand();
	} else {
		nodeOneOfAddCommand(START_INDEX);
	}
	
	return;
}


void CommandPacker::nodeOneOfAddCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->hasMeaning("ADD", index)) {
		nodeTwoOfAddCommand(index+1);
	} else {
		nodeTwoOfAddCommand(index);
	}
	
	return;
}

void CommandPacker::nodeTwoOfAddCommand(int index) {	
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else {
		try {
			_task = _taskPacker->packAddTask(_tokens, index);
			packAddCommand();
		} catch (Exception_ExceededParameterLimit e) {
			packInvalidCommand();
		}
	}

	return;
}


void CommandPacker::nodeOneOfEditCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->isInteger(index) && _tokens->isValidIndex(index)) {
		_singleIndex = stoi(_tokens->getToken(index));
		nodeTwoOfEditCommand(index+1);
	} else {
		_singleIndex = LAST_INDEX;
		nodeTwoOfEditCommand(index);
	}
	
	return;
}

void CommandPacker::nodeTwoOfEditCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else if(_tokens->hasMeaning("TO", index)) {
		nodeThreeOfEditCommand(index+1);
	} else {
		nodeThreeOfEditCommand(index);
	}

	return;
}

void CommandPacker::nodeThreeOfEditCommand(int index) {
	if(_tokens->isOutOfBounds(index)) {
		packInvalidCommand();
	} else {
		try {
			_task = _taskPacker->packEditTask(_tokens, index);
			packEditCommand();
		} catch (Exception_ExceededParameterLimit e) {
			packInvalidCommand();
		}
	}
	
	return;
}


void CommandPacker::packDisplayCommand() {
	_command = new Command_Invalid();
	
	return;
}

void CommandPacker::packChangeDirectoryCommand() {
	_command = new Command_SaveDirectory(_description);
	
	return;
}

void CommandPacker::packChangeViewTypeCommand() {
	_command = new Command_ViewType(_singleIndex);
	
	return;
}

void CommandPacker::packDeleteCommand() {
	vector<int>* deleteList = new vector<int>;

	deleteList->push_back(_singleIndex);

	_command = new Command_Clear(deleteList);
	
	return;
}

void CommandPacker::packDeleteTaskParametersCommand() {
	packDeleteTask();

	_command = new Command_Edit(_indexes, _task);
	
	return;
}

void CommandPacker::packUndoCommand() {
	_command = new Command_Undo();
	
	return;
}

void CommandPacker::packRedoCommand() {
	_command = new Command_Redo();
	
	return;
}

void CommandPacker::packHelpCommand() {
	_command = new Command_Help();
	
	return;
}

void CommandPacker::packExitCommand() {
	_command = new Command_Exit();
	
	return;
}

void CommandPacker::packScrollCommand() {
	_command = new Command_Scroll();
	
	return;
}

void CommandPacker::packClearCommand() {
	_command = new Command_Clear(_indexes);
	
	return;
}

void CommandPacker::packSearchCommand() {
	_command = new Command_Search(_description);
	
	return;
}

void CommandPacker::packMarkCommand() {
	_task = new Task(NO_NAME, NO_DATE_DETECTED, NO_DATE_DETECTED, NO_TIME_DETECTED, NO_TIME_DETECTED, NO_LOCATION_DETECTED, _doneStatus);

	_command = new Command_Edit(_indexes, _task);
	
	return;
}

void CommandPacker::packAddCommand() {
	_command = new Command_Add(_task);
	
	return;
}

void CommandPacker::packEditCommand() {
	vector<int>* editList = new vector<int>;
	editList->push_back(_singleIndex);

	_command = new Command_Edit(editList, _task);
	
	return;
}

void CommandPacker::packInvalidCommand() {
	_command = new Command_Invalid();
	
	return;
}


void CommandPacker::extractTerm(int index) {
	assert(!_tokens->isOutOfBounds(index));
	_description = _tokens->getOriginalToken(index);

	for(index++; !_tokens->isOutOfBounds(index); index++) {
		if(!_tokens->isExtensionOfAWord(index)) {
			_description += BLANK_SPACE;
		}
	_description += _tokens->getOriginalToken(index);
	}

	return;
}

void CommandPacker::extractViewType(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->hasMeaning("VIEWDESCRIPTION", index));

	if(_tokens->hasMeaning("ALL", index)) {
		_singleIndex = 1;
		return;
	} else if(_tokens->hasMeaning("PRESENT", index)) {
		_singleIndex = 2;
		return;
	} else if(_tokens->hasMeaning("TODAY", index)) {
		_singleIndex = 3;
		return;
	}
	
	assert(false); //method should return before reaching this line
	return;
}

void CommandPacker::extractDeleteParameter(int index) {
	assert(!_tokens->isOutOfBounds(index));
	assert(_tokens->hasMeaning("DELETEPARAMETER", index));

	if(_tokens->hasMeaning("DATE", index)) {
		_isDeleteDate = true;
		return;
	} else if(_tokens->hasMeaning("TIME", index)) {
		_isDeleteTime = true;
		return;
	} else if(_tokens->hasMeaning("LOCATION", index)) {
		_isDeleteLocation = true;
		return;
	}
	
	assert(false); //method should return before reaching this line
	return;
}

void CommandPacker::packDeleteTask() {
	string name = NO_NAME;
	int date = NO_DATE_DETECTED;
	int time = NO_TIME_DETECTED;
	string location = NO_LOCATION_DETECTED;
	int doneStatus = NO_DONE_DETECTED;
	
	if(_isDeleteTime) {
		time = NO_TIME;
	}
	if(_isDeleteDate) {
		date = NO_DATE;
	}
	if(_isDeleteLocation) {
		location = NO_LOCATION;
	}

	_task = new Task(name, date, date, time, time, location, doneStatus);

	return;
}


void CommandPacker::addToIndexes(int index) {
	vector<int>& indexRef = *_indexes;

	for(unsigned int i = 0; i < indexRef.size();) {
		if(indexRef[i] == index) {
			indexRef.erase(indexRef.begin()+i);
		} else {
			i++;
		}
	}

	indexRef.push_back(index);
}

void CommandPacker::addRangeToIndexes(int index) {
	vector<int>& indexRef = *_indexes;
	int start = indexRef[indexRef.size()-1];
	int end = index;

	if(end < start) {
		end = start;
		start = index;
	}

	for(int i = start; i <= end; i++) {
		addToIndexes(i);
	}

	return;
}
```
###### doMe\CommandPacker.h
``` h
//
//This is the CommandPacker. This class creates the appropriate command object based on the 
//lexed tokens passed to it. It is an singleton class and pointer to the object should be 
//retrieved using the CommandPacker::getInstance() method.
//The main API is Command* packCommand(InputTokens* tokens);
//description: makes a command object baed on the tokens passed to it and returns the address 
//to the command object.
//Pre-Condition: The tokens pointer should not be NULL
//Post-Condition: A Command object would be created. If required, a Task Object may also be created


#pragma once

#include "Command.h"
#include "Command_Add.h"
#include "Command_Clear.h"
#include "Command_Edit.h"
#include "Command_Exit.h"
#include "Command_Scroll.h"
#include "Command_Invalid.h"
#include "Command_SaveDirectory.h"
#include "Command_Search.h"
#include "Command_Undo.h"
#include "Command_ViewType.h"
#include "Command_Help.h"
#include "Command_Redo.h"
#include "InputTokens.h"
#include "TaskPacker.h"
#include "Task.h"
#include "Exception_ExceededParameterLimit.h"
#include <string>
#include <assert.h>
#include <vector>

#define LAST_INDEX 0
#define NO_STRING ""


using namespace std;

class CommandPacker
{
public:
	~CommandPacker(void);
	static CommandPacker* getInstance();
	Command* packCommand(InputTokens* tokens);

private:
	CommandPacker(void);
	static CommandPacker* _theOne;
	
	TaskPacker* _taskPacker;
	InputTokens* _tokens;

	string _description;
	int _singleIndex;
	vector<int>* _indexes;
	Task* _task;
	Command* _command;
	bool _isDeleteDate;
	bool _isDeleteTime;
	bool _isDeleteLocation;
	int _doneStatus;

	void setEnvironment(InputTokens* tokens);
	void branchToNode(int index); //branches to the various command nodes for parsing

	//Below are the method nodes that check an aspect of every command. The part in the []brackets is the part being checked
	void nodeOneOfDisplayCommand(int index);			//display [1]

	void nodeOneOfChangeDirectoryCommand(int index);	//change [the] directory to some address
	void nodeTwoOfChangeDirectoryCommand(int index);	//change the [directory] to some address 
	void nodeThreeOfChangeDirectoryCommand(int index);	//change the directory [to] some address
	void nodeFourOfChangeDirectoryCommand(int index);	//change the directory to [some address]

	void nodeOneOfChangeViewTypeCommand(int index);		//change the [viewtype] to index
	void nodeTwoOfChangeViewTypeCommand(int index);		//change the viewtype [to] index
	void nodeThreeOfChangeViewTypeCommand(int index);	//change the viewtype to [index]
	void nodeFourOfChangeViewTypeCommand(int index);	//change the viewtype to index []

	void nodeOneOfDeleteCommand(int index);				//delete [1] location date time
	void nodeTwoOfDeleteCommand(int index);				//delete 1 [location] date time
	void nodeThreeOfDeleteCommand(int index);			//delete 1 location [date time]

	void nodeOneOfUndoCommand(int index);				//undo [last]
	void nodeTwoOfUndoCommand(int index);				//undo last []

	void nodeOneOfRedoCommand(int index);				//redo [last]
	void nodeTwoOfRedoCommand(int index);				//redo last []

	void nodeOneOfHelpCommand(int index);				//help []

	void nodeOneOfExitCommand(int index);				//exit []

	void nodeOneOfScrollCommand(int index);				//b []

	void nodeOneOfClearCommand(int index);				//clear []
	void nodeTwoOfClearCommand(int index);				//clear [all]
	void nodeThreeOfClearCommand(int index);			//clear all []
	void nodeFourOfClearCommand(int index);				//clear [1]-5
	void nodeFiveOfClearCommand(int index);				//clear 1[-]5
	void nodeSixOfClearCommand(int index);				//clear 1-[5]
	void nodeSevenOfClearCommand(int index);			//clear 1-5 [location date time]

	void nodeOneOfSearchCommand(int index);				//search [for] the meaning of life
	void nodeTwoOfSearchCommand(int index);				//search for [the meaning of life]
	void nodeThreeOfSearchCommand(int index);

	void nodeOneOfMarkCommand(int index);				//mark [1]-3 as not done
	void nodeTwoOfMarkCommand(int index);				//mark 1[-]3 as not done
	void nodeThreeOfMarkCommand(int index);				//mark 1-[3] as not done
	void nodeFourOfMarkCommand(int index);				//mark 1-3 as [not] done
	void nodeFiveOfMarkCommand(int index);				//mark 1-3 as not [done]
	void nodeSixOfMarkCommand(int index);				//mark [as] not done 1-3
	void nodeSevenOfMarkCommand(int index);				//mark as [not] done 1-3
	void nodeEightOfMarkCommand(int index);				//mark as not [done] 1-3
	void nodeNineOfMarkCommand(int index);				//mark as not done [1]-3
	void nodeTenOfMarkCommand(int index);				//mark as not done 1[-]3
	void nodeElevenOfMarkCommand(int index);			//mark as not done 1-[3]
	void nodeTwelveOfMarkCommand(int index);			//mark as not done 1-3 []

	void nodeOneOfAddCommand(int index);				//[add] submit everything 11 apr 2359
	void nodeTwoOfAddCommand(int index);				//add [submit everything 11 apr 2359]

	void nodeOneOfEditCommand(int index);				//edit [1] to just give up
	void nodeTwoOfEditCommand(int index);				//edit 1 [to] just give up
	void nodeThreeOfEditCommand(int index);				//edit 1 to [just give up]

	//uses global variables to pack the command object
	void packDisplayCommand();
	void packChangeViewTypeCommand();
	void packChangeDirectoryCommand();
	void packDeleteCommand();
	void packDeleteTaskParametersCommand();
	void packUndoCommand();
	void packRedoCommand();
	void packHelpCommand();
	void packExitCommand();
	void packScrollCommand();
	void packClearCommand();
	void packSearchCommand();
	void packMarkCommand();
	void packAddCommand();
	void packEditCommand();
	void packInvalidCommand();

	void extractTerm(int index);			//reads in tokens till the end and stores the read string in _description

	void extractViewType(int index);
	void extractDeleteParameter(int index);	//finds the parameter to delete from a task
	void packDeleteTask();					//packs up the parameters for task deletion

	void addToIndexes(int index);			//adds an integer to the global _indexes variable
	void addRangeToIndexes(int index);		//adds a range of integer to the global _indexes variable
};
```
###### doMe\Dictionary.cpp
``` cpp

#include "Dictionary.h"

Dictionary* Dictionary::_theOne = NULL;

Dictionary::Dictionary(void)
{
	generateVocabulary();
}

Dictionary::~Dictionary(void)
{
	map<string, SynonymList*>::iterator it;
		for(it = _wordMap.begin(); it != _wordMap.end(); it++) {
		delete it->second;
	}
}

Dictionary* Dictionary::getInstance() {
	if(_theOne == NULL) {
		_theOne = new Dictionary;
	}
	return _theOne;
}

bool Dictionary::hasMeaning(string meaning, string s) {
	vector<string>* synonyms = getSynonyms(meaning);
	return isFoundInVector(synonyms, s);
}

void Dictionary::generateVocabulary() { 
	addBasicVocabularyPackage();
	addChronoVocabularyPackage();
	addNaturalLanguagePackage();

	return;
}

void Dictionary::addBasicVocabularyPackage() {
	addSpecialCase();
	addDisplay();
	addDirectory();
	addDelete();
	addAdd();
	addEdit();
	addClear();
	addUndo();
	addSearch();
	addExit();
	addView();
	addChangeDirectory();
	addChangeViewType();
	addDate();
	addLocation();
	addTime();
	addDeleteParameter();
	addDone();
	addUndone();
	addRedo();
	addHelp();
	addMark();
	addScroll();

	return;
}

void Dictionary::addChronoVocabularyPackage() {
	addHrs();
	addDateDivider();
	addTimeDivider();
	addJanuary();
	addFebruary();
	addMarch();
	addApril();
	addMay();
	addJune();
	addJuly();
	addAugust();
	addSeptember();
	addOctober();
	addNovember();
	addDecember();
	addMonthsOfTheYear();
	addMonday();
	addTuesday();
	addWednesday();
	addThursday();
	addFridary();
	addSaturday();
	addSunday();
	addDaysOfTheWeek();
	addWeek();
	addTomorrow();
	addToday();
	addYesterday();
	addRelationalDate();
	addPM();
	addAM();
	addMeridiem();
	addFirst();
	addSecond();
	addThird();
	addFourth();
	addNumberSuffix();
	addRange();

	return;
}

void Dictionary::addNaturalLanguagePackage() {
	addNext();
	addThis();
	addTo();
	addBy();
	addFrom();
	addOn();
	addDue();
	addPreposition();
	addFor();
	addThe();
	addAll();
	addNot();
	addPresent();
	addViewDescription();
	addLast();

	return;
}


void Dictionary::addSpecialCase() {
	SynonymList* list = new SynonymList("SPECIALCASE");
	list->add("-L");
	list->add("-D");
	list->add("-T");
	addToDictionary(list);
}

void Dictionary::addDisplay() {
	SynonymList* list = new SynonymList("DISPLAY");
	list->add("V");
	list->add("DISP");
	list->add("DISPLAY");
	list->add("VIEW");
	addToDictionary(list);
}

void Dictionary::addDirectory() {
	SynonymList* list = new SynonymList("DIRECTORY");
	list->add("DIRECTORY");
	list->add("DIR");
	list->add("D");
	addToDictionary(list);
}

void Dictionary::addDelete() {
	SynonymList* list = new SynonymList("DEL");
	list->add("D");
	list->add("DELETE");
	list->add("DEL");
	addToDictionary(list);
}

void Dictionary::addAdd() {
	SynonymList* list = new SynonymList("ADD");
	list->add("A");
	list->add("ADD");
	addToDictionary(list);
}

void Dictionary::addEdit() {
	SynonymList* list = new SynonymList("EDIT");
	list->add("E");
	list->add("ED");
	list->add("CHANGE");
	list->add("C");
	list->add("CHNG");
	list->add("EDIT");
    list->add("SET");
	addToDictionary(list);
}

void Dictionary::addClear() {
	SynonymList* list = new SynonymList("CLEAR");
	list->add("CLEAR");
	list->add("CLR");
	addToDictionary(list);
}

void Dictionary::addUndo() {
	SynonymList* list = new SynonymList("UNDO");
	list->add("U");
	list->add("UNDO");
	list->add("REVERT");
	addToDictionary(list);
}

void Dictionary::addSearch() {
	SynonymList* list = new SynonymList("SEARCH");
	list->add("SEARCH");
	list->add("SRCH");
	list->add("S");
	addToDictionary(list);
}

void Dictionary::addExit() {
	SynonymList* list = new SynonymList("EXIT");
	list->add("EX");
	list->add("EXIT");
	list->add("CLOSE");
	addToDictionary(list);
}

void Dictionary::addView() {
	SynonymList* list = new SynonymList("VIEW");
	list->add(getSynonyms("DISPLAY"));
	list->add("VIEWTYPE");
	list->add("DISPLAYTYPE");
	list->add("DISPTYPE");
	list->add("VTYPE");
	addToDictionary(list);
}

void Dictionary::addChangeDirectory() {
	SynonymList* list = new SynonymList("CHANGEDIRECTORY");
	list->add(getSynonyms("DIRECTORY"));
	list->add("CD");
	list->add("CDIRECTORY");
	list->add("CDIR");
	list->add("CHANGEDIR");
	list->add("CHANGEDIRECTORY");
	list->add("CHNGD");
	list->add("CHNGDIR");
	list->add("CHNGDIRECTORY");
	addToDictionary(list);
}

void Dictionary::addChangeViewType() {
	SynonymList* list = new SynonymList("CHANGEVIEWTYPE");
	list->add("VIEW");
	list->add("CV");
	list->add("CVIEW");
	list->add("CDISPLAY");
	list->add("CDISP");
	list->add("CHNGVIEW");
	list->add("CHNGV");
	list->add("CHNGDISPLAY");
	list->add("CHNGDISP");
	list->add("CHANGEV");
	list->add("CHANGEVIEW");
	list->add("CHANGEDISPLAY");
	list->add("CHANGEDISP");
	list->add("VIEWTYPE");
	addToDictionary(list);
}

void Dictionary::addDate() {
	SynonymList* list = new SynonymList("DATE");
	list->add("DATE");
	list->add("-D");
	addToDictionary(list);
}

void Dictionary::addLocation() {
	SynonymList* list = new SynonymList("LOCATION");
	list->add("LOCATION");
	list->add("ADDRESS");
	list->add("-L");
	list->add("PLACE");
	addToDictionary(list);
}

void Dictionary::addTime() {
	SynonymList* list = new SynonymList("TIME");
	list->add("TIME");
	list->add("-T");
	addToDictionary(list);
}

void Dictionary::addDeleteParameter() {
	SynonymList* list = new SynonymList("DELETEPARAMETER");
	list->add(getSynonyms("DATE"));
	list->add(getSynonyms("LOCATION"));
	list->add(getSynonyms("TIME"));
	addToDictionary(list);
}

void Dictionary::addDone() {
	SynonymList* list = new SynonymList("DONE");
	list->add("DONE");
	list->add("FINISHED");
	list->add("COMPLETED");
	addToDictionary(list);
}

void Dictionary::addUndone() {
	SynonymList* list = new SynonymList("UNDONE");
	list->add("UNDONE");
	list->add("UNFINISHED");
	list->add("INCOMPLETED");
	list->add("NOTDONE");
	list->add("NOTFINISHED");
	list->add("NOTCOMPLETE");
	addToDictionary(list);
}

void Dictionary::addRedo() {
	SynonymList* list = new SynonymList("REDO");
	list->add("REDO");
	list->add("R");
	addToDictionary(list);
}

void Dictionary::addHelp() {
	SynonymList* list = new SynonymList("HELP");
	list->add("HELP");
	list->add("H");
	list->add("?");
	addToDictionary(list);
}

void Dictionary::addMark() {
	SynonymList* list = new SynonymList("MARK");
	list->add("MARK");
	list->add("MRK");
	addToDictionary(list);
}

void Dictionary::addScroll() {
	SynonymList* list = new SynonymList("SCROLL");
	list->add("B");
	list->add("BROWSE");
	list->add("SCROLL");
	addToDictionary(list);
}


void Dictionary::addHrs() {
	SynonymList* list = new SynonymList("HRS");
	list->add("HRS");
	list->add("HR");
	addToDictionary(list);
}

void Dictionary::addDateDivider() {
	SynonymList* list = new SynonymList("DATEDIVIDER");
	list->add("/");
	addToDictionary(list);
}

void Dictionary::addTimeDivider() {
	SynonymList* list = new SynonymList("TIMEDIVIDER");
	list->add(":");
	list->add(".");
	addToDictionary(list);

	return;
}

void Dictionary::addJanuary() {
	SynonymList* list = new SynonymList("JANUARY");
	list->add("JAN");
	list->add("JANUARY");
	addToDictionary(list);
}

void Dictionary::addFebruary()  {
	SynonymList* list = new SynonymList("FEBRUARY");
	list->add("FEB");
	list->add("FEBRUARY");
	addToDictionary(list);
}

void Dictionary::addMarch() {
	SynonymList* list = new SynonymList("MARCH");
	list->add("MARCH");
	list->add("MAR");
	addToDictionary(list);
}

void Dictionary::addApril() {
	SynonymList* list = new SynonymList("APRIL");
	list->add("APR");
	list->add("APRIL");
	addToDictionary(list);
}

void Dictionary::addMay() {
	SynonymList* list = new SynonymList("MAY");
	list->add("MAY");
	addToDictionary(list);
}

void Dictionary::addJune() {
	SynonymList* list = new SynonymList("JUNE");
	list->add("JUNE");
	list->add("JUN");
	addToDictionary(list);
}

void Dictionary::addJuly() {
	SynonymList* list = new SynonymList("JULY");
	list->add("JUL");
	list->add("JULY");
	addToDictionary(list);
}

void Dictionary::addAugust() {
	SynonymList* list = new SynonymList("AUGUST");
	list->add("AUG");
	list->add("AUGUST");
	addToDictionary(list);
}

void Dictionary::addSeptember() {
	SynonymList* list = new SynonymList("SEPTEMBER");
	list->add("SEP");
	list->add("SEPT");
	list->add("SEPTEMBER");
	addToDictionary(list);
}

void Dictionary::addOctober() {
	SynonymList* list = new SynonymList("OCTOBER");
	list->add("OCTOBER");
	list->add("OCT");
	addToDictionary(list);
}

void Dictionary::addNovember() {
	SynonymList* list = new SynonymList("NOVEMBER");
	list->add("NOVEMBER");
	list->add("NOV");
	addToDictionary(list);
}

void Dictionary::addDecember() {
	SynonymList* list = new SynonymList("DECEMBER");
	list->add("DEC");
	list->add("DECEMBER");
	addToDictionary(list);
}

void Dictionary::addMonthsOfTheYear() {
	SynonymList* list = new SynonymList("MONTHSOFTHEYEAR");
	list->add(getSynonyms("JANUARY"));
	list->add(getSynonyms("FEBRUARY"));
	list->add(getSynonyms("MARCH"));
	list->add(getSynonyms("APRIL"));
	list->add(getSynonyms("MAY"));
	list->add(getSynonyms("JUNE"));
	list->add(getSynonyms("JULY"));
	list->add(getSynonyms("AUGUST"));
	list->add(getSynonyms("SEPTEMBER"));
	list->add(getSynonyms("OCTOBER"));
	list->add(getSynonyms("NOVEMBER"));
	list->add(getSynonyms("DECEMBER"));
	addToDictionary(list);
}

void Dictionary::addMonday() {
	SynonymList* list = new SynonymList("MONDAY");
	list->add("MON");
	list->add("MONDAY");
	addToDictionary(list);
}

void Dictionary::addTuesday() {
	SynonymList* list = new SynonymList("TUESDAY");
	list->add("TUESDAY");
	list->add("TUE");
	list->add("TUES");
	addToDictionary(list);
}

void Dictionary::addWednesday() {
	SynonymList* list = new SynonymList("WEDNESDAY");
	list->add("WED");
	list->add("WEDNESDAY");
	addToDictionary(list);
}

void Dictionary::addThursday() {
	SynonymList* list = new SynonymList("THURSDAY");
	list->add("THUR");
	list->add("THU");
	list->add("THURSDAY");
	list->add("THURS");
	addToDictionary(list);
}

void Dictionary::addFridary() {
	SynonymList* list = new SynonymList("FRIDAY");
	list->add("FRI");
	list->add("FRIDAY");
	addToDictionary(list);
}

void Dictionary::addSaturday() {
	SynonymList* list = new SynonymList("SATURDAY");
	list->add("SAT");
	list->add("SATURDAY");
	addToDictionary(list);
}

void Dictionary::addSunday() {
	SynonymList* list = new SynonymList("SUNDAY");
	list->add("SUN");
	list->add("SUNDAY");
	addToDictionary(list);
}

void Dictionary::addDaysOfTheWeek() {
	SynonymList* list = new SynonymList("DAYSOFTHEWEEK");
	list->add(getSynonyms("MONDAY"));
	list->add(getSynonyms("TUESDAY"));
	list->add(getSynonyms("WEDNESDAY"));
	list->add(getSynonyms("THURSDAY"));
	list->add(getSynonyms("FRIDAY"));
	list->add(getSynonyms("SATURDAY"));
	list->add(getSynonyms("SUNDAY"));
	addToDictionary(list);
}

void Dictionary::addWeek() {
	SynonymList* list = new SynonymList("WEEK");
	list->add("WK");
	list->add("WEEK");
	addToDictionary(list);
}

void Dictionary::addTomorrow() {
	SynonymList* list = new SynonymList("TOMORROW");
	list->add("TMR");
	list->add("TOMORROW");
	addToDictionary(list);
}

void Dictionary::addToday() {
	SynonymList* list = new SynonymList("TODAY");
	list->add("TDAY");
	list->add("TODAY");
	list->add("TDY");
	addToDictionary(list);
}

void Dictionary::addYesterday() {
	SynonymList* list = new SynonymList("YESTERDAY");
	list->add("YSTRDAY");
	list->add("YESTERDAY");
	list->add("YEST");
	addToDictionary(list);
}

void Dictionary::addRelationalDate() {
	SynonymList* list = new SynonymList("RELATIONALDATE");
	list->add(getSynonyms("TODAY"));
	list->add(getSynonyms("TOMORROW"));
	list->add(getSynonyms("YESTERDAY"));
	addToDictionary(list);
}

void Dictionary::addAM() {
	SynonymList* list = new SynonymList("AM");
	list->add("AM");
	addToDictionary(list);
}

void Dictionary::addPM() {
	SynonymList* list = new SynonymList("PM");
	list->add("PM");
	addToDictionary(list);
}

void Dictionary::addMeridiem() {
	SynonymList* list = new SynonymList("MERIDIEM");
	list->add(getSynonyms("AM"));
	list->add(getSynonyms("PM"));
	addToDictionary(list);
}

void Dictionary::addFirst() {
	SynonymList* list = new SynonymList("FIRST");
	list->add("ST");
	addToDictionary(list);
}

void Dictionary::addSecond() {
	SynonymList* list = new SynonymList("SECOND");
	list->add("ND");
	addToDictionary(list);
}

void Dictionary::addThird() {
	SynonymList* list = new SynonymList("THIRD");
	list->add("RD");
	addToDictionary(list);
}

void Dictionary::addFourth() {
	SynonymList* list = new SynonymList("FOURTH");
	list->add("TH");
	addToDictionary(list);
}

void Dictionary::addNumberSuffix() {
	SynonymList* list = new SynonymList("NUMBERSUFFIX");
	list->add(getSynonyms("FIRST"));
	list->add(getSynonyms("SECOND"));
	list->add(getSynonyms("THIRD"));
	list->add(getSynonyms("FOURTH"));
	addToDictionary(list);
}

void Dictionary::addRange() {
	SynonymList* list = new SynonymList("RANGE");
	list->add("TO");
	list->add("-");
	addToDictionary(list);
}


void Dictionary::addNext() {
	SynonymList* list = new SynonymList("NEXT");
	list->add("NEXT");
	list->add("NXT");
	addToDictionary(list);
}

void Dictionary::addThis() {
	SynonymList* list = new SynonymList("THIS");
	list->add("THIS");
	list->add("TIS");
	addToDictionary(list);
}

void Dictionary::addTo() {
	SynonymList* list = new SynonymList("TO");
	list->add("TO");
	list->add("-");
	list->add("AS");
	addToDictionary(list);
}

void Dictionary::addBy() {
	SynonymList* list = new SynonymList("BY");
	list->add("BY");
	addToDictionary(list);
}

void Dictionary::addFrom() {
	SynonymList* list = new SynonymList("FROM");
	list->add("FROM");
	list->add("FRM");
	addToDictionary(list);
}

void Dictionary::addOn() {
	SynonymList* list = new SynonymList("ON");
	list->add("ON");
	addToDictionary(list);
}

void Dictionary::addDue() {
	SynonymList* list = new SynonymList("DUE");
	list->add("DUE");
	addToDictionary(list);
}

void Dictionary::addPreposition() {
	SynonymList* list = new SynonymList("PREPOSITION");
	list->add(getSynonyms("ON"));
	list->add(getSynonyms("FROM"));
	list->add(getSynonyms("TO"));
	list->add(getSynonyms("BY"));
	list->add(getSynonyms("TO"));
	list->add(getSynonyms("DUE"));
	addToDictionary(list);
}

void Dictionary::addFor() {
	SynonymList* list = new SynonymList("FOR");
	list->add("FOR");
	list->add("FR");
	addToDictionary(list);
}

void Dictionary::addThe() {
	SynonymList* list = new SynonymList("THE");
	list->add("THE");
	list->add("TEH");
	addToDictionary(list);
}

void Dictionary::addAll() {
	SynonymList* list = new SynonymList("ALL");
	list->add("ALL");
	list->add("EVERYTHING");
	list->add("EVERYTHIN");
	list->add("EVRYTHING");
	list->add("EVRYTHIN");
	list->add("EVRYTIN");
	list->add("EVERYTIN");
	list->add("EVRYTING");
	list->add("EVERYTING");
	addToDictionary(list);
}

void Dictionary::addNot() {
	SynonymList* list = new SynonymList("NOT");
	list->add("NOT");
	list->add("NT");
	addToDictionary(list);
}

void Dictionary::addPresent() {
	SynonymList* list = new SynonymList("PRESENT");
	list->add("PRESENT");
	list->add("PRSNT");
	addToDictionary(list);
}

void Dictionary::addViewDescription() {
	SynonymList* list = new SynonymList("VIEWDESCRIPTION");
	list->add(getSynonyms("PRESENT"));
	list->add(getSynonyms("ALL"));
	list->add(getSynonyms("TODAY"));
	addToDictionary(list);
}

void Dictionary::addLast() {
	SynonymList* list = new SynonymList("LAST");
	list->add("LAST");
	list->add("LST");
	addToDictionary(list);
}

void Dictionary::addToDictionary(SynonymList* list) {
		_wordMap.insert(pair<string, SynonymList*>(
						list->getMeaning(), 
						list));
	return;
}

vector<string>* Dictionary::getSynonyms(string s) {
	map<string, SynonymList*>::iterator found = _wordMap.find(s);
	assert(found != _wordMap.end());
	return found->second->getSynonyms();
}	 

bool Dictionary::isFoundInVector(vector<string>* vector, string s) {
	assert(vector);
	for(unsigned int i = 0; i < vector->size(); i++) {
		if(s.compare((*vector)[i]) == 0) {
			return true;
		}
	}
	return false;
}
```
###### doMe\Dictionary.h
``` h

#pragma once

#include "SynonymList.h"
#include "Commons.h"
#include <map>
#include <string>
#include <vector>
#include <assert.h>

using namespace std;

class Dictionary
{
public:
	static Dictionary* getInstance();			//method to get pointer to the singleton object

	bool hasMeaning(string meaning, string s);	//returns true if string s has the expected meaning, false otherwise
	~Dictionary(void);

	vector<string>* getSynonyms(string s);		//string must be present in dictionary
	void addToDictionary(SynonymList* list);	//method that adds words to the dictionary

private:
	Dictionary(void);
	
	static Dictionary* _theOne;
	map<string, SynonymList*> _wordMap;

	void generateVocabulary();	//new vocabulary to be added through this method

	void addBasicVocabularyPackage();
	void addChronoVocabularyPackage();
	void addNaturalLanguagePackage();

	void addSpecialCase();		//methods that add vocabulary to the dictionary
	void addDirectory();		
	void addDisplay();
	void addDelete();
	void addAdd();
	void addEdit();
	void addClear();
	void addUndo();
	void addSearch();
	void addExit();
	void addView();
	void addChangeDirectory();
	void addChangeViewType();	
	void addDate();
	void addLocation();
	void addTime();
	void addDeleteParameter();
	void addDone();
	void addUndone();
	void addRedo();
	void addHelp();
	void addMark();
	void addScroll();

	void addHrs();
	void addDateDivider();
	void addTimeDivider();
	void addJanuary();
	void addFebruary();
	void addMarch();
	void addApril();
	void addMay();
	void addJune();
	void addJuly();
	void addAugust();
	void addSeptember();
	void addOctober();
	void addNovember();
	void addDecember();
	void addMonthsOfTheYear();
	void addMonday();
	void addTuesday();
	void addWednesday();
	void addThursday();
	void addFridary();
	void addSaturday();
	void addSunday();
	void addDaysOfTheWeek();
	void addWeek();
	void addTomorrow();
	void addToday();
	void addYesterday();
	void addRelationalDate();
	void addAM();
	void addPM();
	void addMeridiem();
	void addFirst();
	void addSecond();
	void addThird();
	void addFourth();
	void addNumberSuffix();
	void addRange();
	
	void addNext();
	void addThis();
	void addTo();
	void addBy();
	void addFrom();
	void addOn();
	void addDue();
	void addPreposition();
	void addFor();
	void addThe();
	void addAll();
	void addNot();
	void addPresent();
	void addViewDescription();
	void addLast();

	bool isFoundInVector(vector<string>* vector, string s);
};
```
###### doMe\InputTokens.cpp
``` cpp

#include "InputTokens.h"

InputTokens::InputTokens(string commandLine) {
	_dictionary = Dictionary::getInstance();
	generateTokensFromCommandLine(commandLine);
}

InputTokens::~InputTokens(void) {
}

string InputTokens::getToken(int index) {
	assert(!isOutOfBounds(index));
	
	return _tokens[index];
}

string InputTokens::getOriginalToken(int index) {
	assert(!isOutOfBounds(index));
	
	return _tokensOriginal[index];
}

int InputTokens::getInteger(int index) {
	assert(!isOutOfBounds(index));
	assert(isInteger(index));
	
	if(getSize(index) > 9) {
		//number is too large and so return largest integer
		return INT_MAX;
	} else {
		return stoi(_tokens[index]);
	}
}

unsigned int InputTokens::getSize() {
	return _tokens.size();
}

unsigned int InputTokens::getSize(int index) {
	assert(!isOutOfBounds(index));
	
	return _tokens[index].size();
}


bool InputTokens::isOutOfBounds(int index) {
	if(index < 0) {
		return true;
	}

	unsigned int positiveIndex = index;
	
	return (positiveIndex >= _tokens.size());
}

bool InputTokens::hasNoMoreWord(int index) {
	while(!isOutOfBounds(index) && _tokensOriginal[index] == NO_STRING) {
		index++;
	}
	
	return isOutOfBounds(index);
}

bool InputTokens::hasMeaning(string meaning, int index) {
	assert(!isOutOfBounds(index));
	
	return _dictionary->hasMeaning(meaning, _tokens[index]);
}

bool InputTokens::isInteger(int index) {
	assert(!isOutOfBounds(index));

	return (_tokens[index].find_first_not_of("1234567890") == string::npos);
}

bool InputTokens::isValidIndex(int index) {
	assert(!isOutOfBounds(index));

	if(!isInteger(index)) {
		return false;
	} else if(isOutOfBounds(index+1)) {
		return true;
	} else if(isExtensionOfAWord(index+1)) {
		return false;
	} else if(hasMeaning("MERIDIEM", index+1)) {
		return false;
	} else if(hasMeaning("MONTHSOFTHEYEAR", index+1)) {
		return false;
	} else if(hasMeaning("HRS", index+1)) {
		return false;
	} else if(hasMeaning("TIMEDIVIDER", index+1)) {
		return false;
	} else if(hasMeaning("DATEDIVIDER", index+1)) {
		return false;
	} else if(hasMeaning("NUMBERSUFFIX", index+1)) {
		return false;
	} else {
		return true;
	}
}

bool InputTokens::isParsed(int index) {
	assert(!isOutOfBounds(index));
	
	return !(_tokens[index] < "a");
}

bool InputTokens::isExtensionOfAWord(int index) {
	assert(!isOutOfBounds(index));
	
	return (_tokensOriginal[index] == NO_STRING);
}

bool InputTokens::isBreakPoint(int index) {
	return isOutOfBounds(index) || isParsed(index);
}

bool InputTokens::isMarkedAs(string marker, int index) {
	assert(!isOutOfBounds(index));
	
	return (_tokens[index].compare(marker) == 0);
}


void InputTokens::markAs(string marker, int index) {
	assert(!isOutOfBounds(index));
	assert(isLowerCase(marker));

	_tokens[index] = marker;
	
	return;
}

void InputTokens::markAs(string firstMarker, string secondMarker, int index) {
	assert(!isOutOfBounds(index));
	assert(isLowerCase(firstMarker));
	
	_tokens[index] = firstMarker;
	_tokensOriginal[index] = secondMarker;
	
	return;
}

void InputTokens::remove(int index) {
	assert(!isOutOfBounds(index));
	
	_tokens.erase(_tokens.begin()+index);
	_tokensOriginal.erase(_tokensOriginal.begin()+index);
	
	return;
}


void InputTokens::generateTokensFromCommandLine(string commandLine) {
	assert(commandLine.size() != 0);
	
	istringstream is(commandLine);
	string chunk;
	while(is >> chunk) {
		chunk = removeIllegalCharacter(chunk);
		if(chunk.size() == 0) {
			continue;
		}

		//words starting with * are ignored from parsing
		if(chunk[START_INDEX] == '*') {
			chunk.erase(chunk.begin());
			addToVector(IGNORE_MARKER, chunk);
		} else if(_dictionary->hasMeaning("SPECIALCASE", makeAllCaps(chunk))) {
			addToVector(makeAllCaps(chunk), chunk);
		} else {
			//if a word contains alphabets and numbers, this function split them to get the tokens
			vector<string> tokens = getTokensFromChunk(makeAllCaps(chunk));
			assert(tokens.size() != 0);
		
			addToVector(tokens[START_INDEX], chunk);
			for(unsigned int i = 1; i < tokens.size(); i++) {
				addToVector(tokens[i], NO_STRING);
			}
		}
	}

	return;
}


void InputTokens::addToVector(string token, string original) {
	_tokens.push_back(token);
	_tokensOriginal.push_back(original);

	return;
}

vector<string> InputTokens::getTokensFromChunk(string chunk) {
	assert(chunk.size() > 0);
	
	vector<string> tokens;
	size_t index = START_INDEX;
	
	while(index != string::npos) {
		if(isInteger(chunk[index])) {
			index = getNumbers(index, chunk, &tokens);
		} else {
			index = getAlphabets(index, chunk, &tokens);
		}
	}
	
	return tokens;
}


size_t InputTokens::getAlphabets(size_t index, string chunk, vector<string>* tokens) {
	assert(index != string::npos);
	assert(tokens != NULL);
	assert(chunk.size() > 0);
	assert(chunk.size() > index);
	
	size_t next = chunk.find_first_of("0123456789-/:.", index);
	if(next == index) {
	} else if(next != string::npos) {
		tokens->push_back(chunk.substr(index,next-index));
	} else {
		tokens->push_back(chunk.substr(index));
	}
	
	if(next != string::npos && next == chunk.find_first_of("-/:.", index)) {
		tokens->push_back(chunk.substr(next,1));
		next++;
		if(next >= chunk.size()) {
			next = string::npos;
		}
	}

	return next;
}

size_t InputTokens::getNumbers(size_t index, string chunk, vector<string>*  tokens) {
	assert(index != string::npos);
	assert(tokens != NULL);
	assert(chunk.size() > 0);
	assert(chunk.size() > index);
	
	size_t next = chunk.find_first_not_of("0123456789", index);
	if(next != string::npos) {
		tokens->push_back(chunk.substr(index,next-index));
	} else {
		tokens->push_back(chunk.substr(index));
	}
	
	return next;
}

string InputTokens::makeAllCaps(string s) {
	transform(s.begin(), s.end(), s.begin(), toupper);
	
	return s;
}

string InputTokens::removeIllegalCharacter(string s) {
	for(unsigned int i = 0; i < s.size(); i++) {
		while(i < s.size() && isIllegalCharacter(s[i])) {
			s.erase(s.begin()+i);
		}
	}

	return s;
}


bool InputTokens::isInteger(char c) {
	return (c >= '0' && c <= '9');
}

bool InputTokens::isLowerCase(string s) {
	assert(s.size() != 0);

	return (s.find_first_of("ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890") == string::npos);
}

bool InputTokens::isIllegalCharacter(char c) {
	return (c >= 1 && c <= 31) || c == 127;
}
```
###### doMe\InputTokens.h
``` h

#pragma once

#include "Dictionary.h"
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>
#include <assert.h>
#include <cstddef>

#define START_INDEX 0
#define SECOND_INDEX 1
#define NO_STRING ""
#define IGNORE_MARKER "Ignore"

using namespace std;

class InputTokens
{
public:
	InputTokens(string commandLine);
	~InputTokens(void);
	
	//An array of methods to allow
	//other classes to analyze and 
	//retrieve the tokens for parsing
	string getToken(int index);			//returns the token used for parsing
	string getOriginalToken(int index);	//returns the original token
	int getInteger(int index);			//returns int value of the token denoted by the index
	unsigned int getSize();				//returns total number of tokens
	unsigned int getSize(int index);	//returns number of characters in the token denoted by the index

	bool isOutOfBounds(int index);				//checks if the index is out of the bounds of the tokens
	bool hasNoMoreWord(int index);				//checks if the there are anymore words to be parsed
	bool hasMeaning(string meaning, int index);	//checks if the token denoted by index has the expected meaning	
	bool isInteger(int index);					//checks if the token is a number					
	bool isValidIndex(int index);				//checks if the number is an index
	bool isParsed(int index);					//checks if a the token has already been processed
	bool isExtensionOfAWord(int index);			//checks if the token is an extension of a word inputted by user
	bool isBreakPoint(int index);				//checkks if the point indicated by index is the end point of a token chain collection
	bool isMarkedAs(string marker, int index);	//checks if the token indicated by index has the same value as marker


	void markAs(string marker, int index);
	void markAs(string firstMarker, string secondMarker, int index);
	void remove(int index);

private:
	vector<string> _tokensOriginal;
	vector<string> _tokens;
	Dictionary* _dictionary;
	
	//private method that lexes the commandline passed during construction into tokens
	//the lexing will split the commandline based on white spaces and
	//further splits words into strings of numbers or alphabets
	//there will be 2 sets of tokens, 1 set will contain authentic information about the original command
	//the other will be capitalized to remove case sensitivity and can be marked by lower case letters
	//to indicate that the token's information has been extracted
	void generateTokensFromCommandLine(string commandLine);

	void addToVector(string token, string original);
	vector<string> getTokensFromChunk(string chunk);

	size_t getAlphabets(size_t index, string chunk, vector<string>* tokens);
	size_t getNumbers(size_t index, string chunk, vector<string>*  tokens);
	string makeAllCaps(string s);
	string removeIllegalCharacter(string s);

	bool isInteger(char c);
	bool isLowerCase(string s);
	bool isIllegalCharacter(char c);
};
```
###### doMe\Parser.cpp
``` cpp

#include "Parser.h"

Parser* Parser::_theOne = NULL;

Parser::Parser(void) {
	_commandPacker = CommandPacker::getInstance();
}

Parser::~Parser(void) {
}

Parser* Parser::getInstance() {
	if(_theOne == NULL) {
		_theOne = new Parser;
	}

	return _theOne;
}

Command* Parser::parse(string userInput) {
	assert(userInput.size() != 0);

	InputTokens* tokens = new InputTokens(userInput);
	Command* command = _commandPacker->packCommand(tokens);
	
	delete tokens;
	return command;
}
```
###### doMe\Parser.h
``` h

#pragma once

#include "Parser_Interface.h"
#include "CommandPacker.h"
#include "Command.h"
#include "InputTokens.h"
#include <string>
#include <assert.h>

using namespace std;

class Parser : public Parser_Interface
{
public:	
	~Parser(void);
	static Parser* getInstance();
	Command* parse(string userInput);

private:
	Parser(void);
	static Parser* _theOne;
	CommandPacker* _commandPacker;
};
```
###### doMe\Parser_Interface.cpp
``` cpp

#include "Parser_Interface.h"

Parser_Interface::Parser_Interface(void) {
}

Parser_Interface::~Parser_Interface(void) {
}
```
###### doMe\Parser_Interface.h
``` h

#pragma once

#include "Command.h"
#include <string>

using namespace std;

class Parser_Interface
{
public:
	Parser_Interface(void);
	~Parser_Interface(void);
	virtual Command* parse(string newCommandLine) = 0;
};
```
###### doMe\SynonymList.cpp
``` cpp

#include "SynonymList.h"

SynonymList::SynonymList(string meaning) :
_meaning(meaning)
{
	_synonyms = new vector<string>;
}

SynonymList::~SynonymList() {
	delete _synonyms;
}

string SynonymList::getMeaning() {
	return _meaning;
}

vector<string>* SynonymList::getSynonyms() {
	return _synonyms;
}

void SynonymList::add(string synonym)  {
	assert(synonym.compare("") != 0);
	
	_synonyms->push_back(synonym);
	
	return;
}

void SynonymList::add(vector<string>* synonyms) {
	assert(synonyms);
	vector<string>& synonymsRef = *synonyms;
	
	for(unsigned int i = 0; i < synonyms->size(); i++) {
		_synonyms->push_back(synonymsRef[i]);
	}

	return;
}
```
###### doMe\SynonymList.h
``` h

#pragma once

#include <vector>
#include <string>
#include <assert.h>

using namespace std;

class SynonymList
{
public:
	SynonymList(string meaning);
	~SynonymList(void);

	string getMeaning();
	vector<string>* getSynonyms();
	void add(string synonym);
	void add(vector<string>* synonyms);

private:
	vector<string>* _synonyms;
	string _meaning;
};
```
###### doMe\TaskPacker.cpp
``` cpp

#include "TaskPacker.h"

TaskPacker* TaskPacker::_theOne = NULL;

TaskPacker::TaskPacker(void) {
	_chronoInterpreter = ChronoInterpreter::getInstance();
}

TaskPacker::~TaskPacker(void) {
}

TaskPacker* TaskPacker::getInstance() {
	if(_theOne == NULL) {
		_theOne = new TaskPacker;
	}

	return _theOne;
}


Task* TaskPacker::packAddTask(InputTokens* tokens, int index) {
	assert(tokens);
	assert(!tokens->isOutOfBounds(index));

	packStandardTask(tokens, index);
	customizeTaskForAddCommand();
	
	return _task;
}

Task* TaskPacker::packEditTask(InputTokens* tokens, int index) {
	assert(tokens);
	assert(!tokens->isOutOfBounds(index));

	packStandardTask(tokens, index);
	customizeTaskForEditCommand();
	
	return _task;
}


void TaskPacker::packStandardTask(InputTokens* tokens, int index) {
	assert(tokens);
	assert(!tokens->isOutOfBounds(index));

	setEnvironment(tokens);
	findTaskDetails(index);
	_task = new Task(_name, _date1, _date2, _time1, _time2, _location, _doneStatus);
	
	return;
}

void TaskPacker::customizeTaskForAddCommand() {
	if(_task->getDate2() == NO_DATE && _task->getTime2() != NO_TIME) {
		_task->setDate2(DATE);
		if(_task->getTime1() == NO_TIME && _task->getTime2() < TIME ) {
			_task->setDate2(ADD_TO_DATE(1, DATE));
		} else if(_task->getTime1() != NO_TIME && 
				  _task->getTime1() < TIME &&
				  _task->getTime2() < TIME) {
			_task->setDate2(ADD_TO_DATE(1, DATE));
		}
	}

	if(_task->getTime1() != NO_TIME && _task->getTime1() > _task->getTime2()) {
		if(_task->getDate1() == NO_DATE) {
			_task->setDate1(_task->getDate2());
			_task->setDate2(ADD_TO_DATE(1,_task->getDate2()));
		} else if(_task->getDate1() == _task->getDate2()) {
			_task->setDate1(_task->getDate2());
			_task->setDate2(ADD_TO_DATE(1,_task->getDate2()));
		}
	}

	if(_task->getDate1() != NO_DATE && _task->getDate1() > _task->getDate2()) {
		int tempTime = _task->getTime2();
		int tempDate = _task->getDate2();
		_task->setTime2(_task->getTime1());
		_task->setDate2(_task->getDate1());
		_task->setTime1(tempTime);
		_task->setDate1(tempDate);
		if(_task->getTime2() == NO_TIME) {
			_task->setTime2(_task->getTime1());
			_task->setTime1(NO_TIME);
		}
	}
	
	if(_task->getDoneStatus() == NO_DONE_DETECTED) {
		_task->setDoneStatus(NO_DONE);
	}

	if(_task->getDate1() == _task->getDate2() && 
	  (_task->getDate1() != -1 || _task->getDate2() != -2)) {
		  _task->setDate1(-1);
	}

	return;
}

void TaskPacker::customizeTaskForEditCommand() {
	
	if(_task->getDate2() != NO_DATE && _task->getTime1() != NO_TIME && _task->getTime1() > _task->getTime2()) {
		if(_task->getDate1() == NO_DATE) {
			_task->setDate1(_task->getDate2());
			_task->setDate2(ADD_TO_DATE(1,_task->getDate2()));
		} else if(_task->getDate1() == _task->getDate2()) {
			_task->setDate1(_task->getDate2());
			_task->setDate2(ADD_TO_DATE(1,_task->getDate2()));
		}
	}

	if(_task->getDate1() != NO_DATE && _task->getDate1() > _task->getDate2()) {
		int tempTime = _task->getTime2();
		int tempDate = _task->getDate2();
		_task->setTime2(_task->getTime1());
		_task->setDate2(_task->getDate1());
		_task->setTime1(tempTime);
		_task->setDate1(tempDate);
		if(_task->getTime2() == NO_TIME) {
			_task->setTime2(_task->getTime1());
			_task->setTime1(NO_DATE);
		}
	}

	if(_task->getDate1() == _task->getDate2() && 
	  (_task->getDate1() != -1 || _task->getDate2() != -2)) {
		  _task->setDate1(-1);
	}
	
	
	if(_task->getTime1() == NO_TIME) {
		_task->setTime1(NO_TIME_DETECTED);
	}
	if(_task->getTime2() == NO_TIME) {
		_task->setTime2(NO_TIME_DETECTED);
	}
	if(_task->getDate1() == NO_DATE) {
		_task->setDate1(NO_DATE_DETECTED);
	}
	if(_task->getDate2() == NO_DATE) {
		_task->setDate2(NO_DATE_DETECTED);
	}
	if(_task->getLocation() == NO_LOCATION) {
		_task->setLocation(NO_LOCATION_DETECTED);
	}

	return;
}

void TaskPacker::setEnvironment(InputTokens* tokens) {
	_tokens = tokens;
	_name = NO_NAME;
	_date1 = NO_DATE;
	_date2 = NO_DATE;
	_time1 = NO_TIME;
	_time2 = NO_TIME;
	_location = NO_LOCATION;
	_dates.clear();
	_times.clear();
	_doneStatus = NO_DONE_DETECTED;

	return;
}

void TaskPacker::findTaskDetails(int index) {
	findDateAndTime(index);
	findDoneStatus(index);
	findLocation(index);
	findName(index);

	return;
}


void TaskPacker::findDateAndTime(int index) {
	_chronoInterpreter->interpretDateAndTime(_tokens, index);
	findTime(index);
	findDate(index);

	return;
}


void TaskPacker::findDate(int index) {
	extractDates(index);
	finalizeDates();
	return;
}

void TaskPacker::extractDates(int index) {
	for(unsigned int i = index; i < _tokens->getSize(); i++) {
		if(_tokens->isMarkedAs(DATE_MARKER, (int) i)) {
			_dates.push_back(stoi(_tokens->getOriginalToken((int) i)));
		}
	}

	return;
}

void TaskPacker::finalizeDates() {
	if(_dates.size() == 0) {
		_date1 = NO_DATE;
		_date2 = NO_DATE;
	} else if(_dates.size() == 1) {
		_date1 = NO_DATE;
		_date2 = _dates[FIRST_INDEX];
	} else if(_dates.size() == 2) {
		_date1 = _dates[FIRST_INDEX];
		_date2 = _dates[SECOND_INDEX];
	} else if(_dates.size() > 2) {
		throw Exception_ExceededParameterLimit();
	}
	return;
}	


void TaskPacker::findTime(int index) {
	extractTimes(index);
	finalizeTimes();
	return;
}

void TaskPacker::extractTimes(int index) {
	for(unsigned int i = index; i < _tokens->getSize(); i++) {
		if(_tokens->isMarkedAs(TIME_MARKER, (int) i)) {
			_times.push_back(stoi(_tokens->getOriginalToken((int) i)));
		}
	}
		return;
}

void TaskPacker::finalizeTimes() {
	if(_times.size() == 0) {
		_time2 = NO_TIME;
		_time1 = NO_TIME;
	} else if(_times.size() == 1) {
		_time2 = _times[FIRST_INDEX];
		_time1 = NO_TIME;
	} else if(_times.size() == 2) {
		_time1 = _times[FIRST_INDEX];
		_time2 = _times[SECOND_INDEX];
	} else if(_times.size() > 2) {
		throw Exception_ExceededParameterLimit();
	}
	return;
}

void TaskPacker::findDoneStatus(int index) {
	for(unsigned int i = index; i < _tokens->getSize(); i++) {
		if(_tokens->isExtensionOfAWord((int) i)) {
			continue;
		} else if(_tokens->hasMeaning("DONE", (int) i)) {
			_doneStatus = DONE;
			_tokens->markAs(DONE_MARKER, (int) i);
			break;
		} else if(_tokens->hasMeaning("UNDONE", (int) i)) {
			_doneStatus = NO_DONE;
			_tokens->markAs(DONE_MARKER, (int) i);
			break;
		} else if(_tokens->hasMeaning("NOT", (int) i)) {
			if(!_tokens->isOutOfBounds((int) i+1) && !_tokens->hasMeaning("DONE", (int) i+1)) {
			_doneStatus = NO_DONE;
			_tokens->markAs(DONE_MARKER, (int) i);
			_tokens->remove((int) i+1);
			break;
			}
		}
	}
}

void TaskPacker::findLocation(int index) {
	for(unsigned int i = index; i < _tokens->getSize(); i++) {
		if(hasLocationMarker(_tokens->getToken((int) i))) {
			extractLocation((int) i);
		}
	}
}

void TaskPacker::extractLocation(int index) {
	assert(!_tokens->isOutOfBounds(index));
	
	string location = extractStringToBreakPoint(LOCATION_MARKER, index);
	if(_location.compare(NO_LOCATION) == 0) {
		_location = removeLocationMarker(location);
	} else if(_location.compare(NO_LOCATION) != 0) {
		throw Exception_ExceededParameterLimit();
	}

	return;
}

string TaskPacker::removeLocationMarker(string s) {
	assert(s[START_INDEX] == '@');
	s.erase(s.begin());
	return s;
}

bool TaskPacker::hasLocationMarker(string s) {
	if(s[START_INDEX] == '@') {
		return true;
	} else {
		return false;
	}
}


void TaskPacker::findName(int index) {
	for(unsigned int i = index; i < _tokens->getSize(); i++) {
		if(!_tokens->isParsed((int) i)) {
			extractName((int) i);
		}
	}
}

void TaskPacker::extractName(int index) {
	assert(!_tokens->isOutOfBounds(index));
	string name = extractStringToBreakPoint(NAME_MARKER, index);
	if(_name == NO_NAME) {
		_name = name;
	} else if(_name.size() < name.size()) {
		_name = name;
	}

	return;
}


string TaskPacker::extractStringToBreakPoint(string marker, int index) {
	assert(!(_tokens->isOutOfBounds(index)));
	string s = _tokens->getOriginalToken(index);
	_tokens->markAs(marker, index);
	for(index++; !_tokens->isBreakPoint(index); index++) {
		if(!_tokens->isExtensionOfAWord(index)) {
			s += BLANK_SPACE;
		}
		s += _tokens->getOriginalToken(index);
		_tokens->markAs(marker, index);
	}
	return s;
}
```
###### doMe\TaskPacker.h
``` h

#pragma once

#include "Task.h"
#include "InputTokens.h"
#include "ChronoInterpreter.h"
#include "Exception_ExceededParameterLimit.h"
#include <string>
#include <assert.h>

#define BLANK_SPACE " " 
#define LOCATION_MARKER "location"
#define NAME_MARKER "name"
#define DONE_MARKER "done"
#define NO_DATE_DETECTED -2
#define NO_TIME_DETECTED -2
#define NO_LOCATION_DETECTED " "
#define NO_DONE_DETECTED -1
#define FIRST_INDEX 0


using namespace std;

class TaskPacker
{
public:
	~TaskPacker(void);
	static TaskPacker* getInstance();
	Task* packAddTask(InputTokens* tokens, int index);
	Task* packEditTask(InputTokens* tokens, int index);

private:
	TaskPacker(void);
	static TaskPacker* _theOne;
	
	InputTokens* _tokens;
	ChronoInterpreter* _chronoInterpreter;

	Task* _task;
	string _name;
	vector<int> _dates;
	vector<int> _times;
	int _date1;
	int _date2;
	int _time1;
	int _time2;
	string _location;
	int _doneStatus;

	void packStandardTask(InputTokens* tokens, int index);

	void customizeTaskForAddCommand();
	void customizeTaskForEditCommand();

	void setEnvironment(InputTokens* tokens);
	void findTaskDetails(int index);

	void findDateAndTime(int index);
	void findDoneStatus(int index);
	void findLocation(int index);
	void findName(int index);

	void findDate(int index);
	void extractDates(int index);
	void finalizeDates();
	
	void findTime(int index);
	void extractTimes(int index);
	void finalizeTimes();

	void extractLocation(int index);
	string removeLocationMarker(string s);
	bool hasLocationMarker(string s);

	void extractName(int index);

	string extractStringToBreakPoint(string marker, int index);
};
```
###### ParserTest\ParserTest.cpp
``` cpp

#include "stdafx.h"
#include "CppUnitTest.h"

#include "Exception_CorruptedFile.cpp"
#include "Exception_ExceededParameterLimit.cpp"
#include "Exception_FileCannotOpen.cpp"
#include "Exception_FirstTimeUser.cpp"
#include "Exception_InvalidCommand.cpp"
#include "Exception_CommandScroll.cpp"

#include "Memory.cpp"
#include "Settings.cpp"
#include "RAM.cpp"
#include "Storage.cpp"
#include "Logic.cpp"
#include "Commons.cpp"
#include "Task.cpp"
#include "Command.cpp"
#include "Command_Add.cpp"
#include "Command_Clear.cpp"
#include "Command_Edit.cpp"
#include "Command_Exit.cpp"
#include "Command_Help.cpp"
#include "Command_Invalid.cpp"
#include "Command_Redo.cpp"
#include "Command_Scroll.cpp"
#include "Command_SaveDirectory.cpp"
#include "Command_Search.cpp"
#include "Command_Undo.cpp"
#include "Command_ViewType.cpp"

#include "UserInterface.cpp"
#include "CommandFeedback.cpp"
#include "ViewType.cpp"
#include "ViewType0.cpp"
#include "ViewType1.cpp"
#include "ViewType2.cpp"
#include "ViewType3.cpp"

#include "SynonymList.h"
#include "SynonymList.cpp"
#include "Dictionary.cpp"
#include "InputTokens.cpp"
#include "ChronoInterpreter.cpp"
#include "TaskPacker.cpp"
#include "CommandPacker.cpp"
#include "Parser_Interface.cpp"
#include "Parser.cpp"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace ParserTest
{		
	TEST_CLASS(AddTest)
	{
	public:
		//these cases are to test different pathways when adding tasks
		TEST_METHOD(Parser_Add_Simple)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home");
			Command* expected = new Command_Add(new Task("go home"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Add_NaturalLanguage)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("add go home");
			Command* expected = new Command_Add(new Task("go home"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Add_1Date)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 1/2/2005");
			Command* expected = new Command_Add(new Task("go home",NO_DATE, 20050201));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Add_2Date)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 01/02/2005 03/02/2005");
			Command* expected = new Command_Add(new Task("go home", 20050201, 20050203));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Add_1Time)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 2359 hrs");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, NO_TIME, 2359));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Add_2Time)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 2358 hrs 2359hrs");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, 2358, 2359));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Add_Location)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home @istanah");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, NO_DATE, NO_TIME, NO_TIME, "istanah"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Add_MultiWordLocation)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home @the grand buddapest hotel");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, NO_DATE, NO_TIME, NO_TIME, "the grand buddapest hotel"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Add_All)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go on holiday 03/2/2016 800hrs @the grand buddapest hotel 04/02 1800hrs ");
			Command* expected = new Command_Add(new Task("go on holiday", 20160203, 20160204, 800, 1800, "the grand buddapest hotel"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Add_All_doneStatus)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go on holiday 03/2/2016 800hrs @the grand buddapest hotel 04/02 1800hrs done");
			Command* expected = new Command_Add(new Task("go on holiday", 20160203, 20160204, 800, 1800, "the grand buddapest hotel", 1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Add_Invalid_TooManyDate)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go on holiday 3/2 4/2 5/2");
			Command* expected = new Command_Invalid();
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Add_Invalid_TooManyTime)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go on holiday 0800 0810 0815");
			Command* expected = new Command_Invalid();
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
	};

	TEST_CLASS(IgnoreTest)
	{
	public:
		//these cases are to test functionality of *command to ignore parsing
		TEST_METHOD(Parser_Ignore_Search)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("*search for house keys");
			Command* expected = new Command_Add(new Task("search for house keys"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Ignore_Digits)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("hit target of making a *1000 sales");
			Command* expected = new Command_Add(new Task("hit target of making a 1000 sales"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
		//these test cases handle ambiguities
		TEST_METHOD(Parser_Ambiguity_4Digits)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("hit target of making a $1000 worth of sales");
			Command* expected = new Command_Add(new Task("hit target of making a $1000 worth of sales"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Ambiguity_4Digits_Back)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("hit target of making a 1000dollas worth of sales");
			Command* expected = new Command_Add(new Task("hit target of making a 1000dollas worth of sales"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Ambiguity_6Digits)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go friends house @blah blah blk blah S160405");
			Command* expected = new Command_Add(new Task("go friends house", -1, -1, -1, -1, "blah blah blk blah S160405"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
	};

	TEST_CLASS(ChronoTest)//this class tests chrono interpretations
	{
	public:
		//Following test cases based on equivalence partitioning.
		TEST_METHOD(Parser_ValidDate_LowerBorder)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 01012016");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20160101));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ValidDate_HigherBorder)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 31122016");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20161231));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_InvalidDay_TooHigh)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 32032016");
			Command* expected = new Command_Add(new Task("go home 32032016"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_InvalidDay_TooLow)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 00012016");
			Command* expected = new Command_Add(new Task("go home 00012016"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_InvalidMonth_TooHigh)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 21132016");
			Command* expected = new Command_Add(new Task("go home 21132016"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_InvalidMonth_TooLow)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 21002016");
			Command* expected = new Command_Add(new Task("go home 21002016"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ValidLeapYear)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 29/2/2016");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20160229));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_InvalidLeapYear)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 29022015");
			Command* expected = new Command_Add(new Task("go home 29022015"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_InvalidLeapYear_YearMultipleOf100)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 29022100");
			Command* expected = new Command_Add(new Task("go home 29022100"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ValidLeapYear_YearMultipleOf400)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 29022400");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 24000229));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ValidTime_UpperBorder)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 2359");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, NO_TIME, 2359));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ValidTime_LowerBorder)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home tday 0000");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, NO_TIME, 0));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_InvalidMinute_TooHigh)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 0060");
			Command* expected = new Command_Add(new Task("go home 0060"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_InvalidHour_TooHigh)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 2400");
			Command* expected = new Command_Add(new Task("go home 2400"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		//following test cases in chrono test are all based on pathways
		TEST_METHOD(Parser_TimeFormatA_4Digit)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home tday 0000hrs");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, NO_TIME, 0));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeFormatA_3Digit)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home tday 800hrs");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, NO_TIME, 800));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeFormatA_Ambiguity1)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 12th feb 1330");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20160212, NO_TIME, 1330));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeFormatA_Ambiguity2)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home feb 12 1330");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20160212, NO_TIME, 1330));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeFormatA_Ambiguity3)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home feb 12 17 1330");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20170212, NO_TIME, 1330));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeFormatB_1Digit)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home tday 1am");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, NO_TIME, 100));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeFormatB_2Digit)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home tday 11am");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, NO_TIME, 1100));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeFormatB_3Digit)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home tday 130am");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, NO_TIME, 130));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeFormatB_4Digit)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home tday 1130am");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, NO_TIME, 1130));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeFormatB_PMTest)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home tday 1130pm");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, NO_TIME, 2330));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeFormatB_12AM)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home tday 1230am");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, NO_TIME, 30));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeFormatB_12PM)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home tday 1230pm");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, NO_TIME, 1230));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
		
		TEST_METHOD(Parser_TimeFormatB_NonsenseMeridiemTime)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 1330pm tday");
			Command* expected = new Command_Add(new Task("go home 1330pm", NO_DATE, DATE));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeRangeFormatA_Standard)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 8-1130pm tday");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, 2000, 2330));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeRangeFormatA_InversedMeridiem)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 8-230pm tday");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, 800, 1430));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeRangeFormatA_InversedMeridiem_NextDay)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 8-230am tday");
			Command* expected = new Command_Add(new Task("go home", DATE, ADD_TO_DATE(1, DATE), 2000, 230));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeRangeFormatA_XXTo12am)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 8-1230am tday");
			Command* expected = new Command_Add(new Task("go home", DATE, ADD_TO_DATE(1, DATE), 2000, 30));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeRangeFormatA_XXTo12pm)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 8-1230pm tday");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, 800, 1230));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeRangeFormatA_12ToXXam)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 12-1130am tday");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, 0, 1130));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeRangeFormatA_12ToXXpm)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 1215-1130pm tday");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, 1215, 2330));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeRangeFormatA_12To12am)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 12-1230am tday");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, 0, 30));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeRangeFormatA_12To12pm)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 1215-1230pm tday");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, 1215, 1230));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeRangeFormatA_12To12am_Reversed)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 1245-1230am tday");
			Command* expected = new Command_Add(new Task("go home", DATE, ADD_TO_DATE(1, DATE), 1245, 30));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeRangeFormatA_12To12pm_Reversed)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 1245-1230pm tday");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, 45, 1230));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeRangeFormatA_24Hrs)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 800-1130hrs tday");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, 800, 1130));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeRangeFormatA_24Hrs_Reversed)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 1100-1030hrs tday");
			Command* expected = new Command_Add(new Task("go home", DATE, ADD_TO_DATE(1, DATE), 1100, 1030));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_TimeRangeFormatA_24Hrs_1digit)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 8-1030hrs tday");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE, 800, 1030));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatA_Type1)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 2/3");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20160302));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatA_Type2)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 21/3");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20160321));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatA_Type3)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 1/11");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20161101));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatA_Type4)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 22/11");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20161122));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatA_Type5)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 22/11/18");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20181122));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatA_Type6)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 22/11/2117");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 21171122));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatC_Type1)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home feb 3rd");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20160203));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatC_Type2)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home feb 3");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20160203));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatD_Type1)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 3 feb");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20160203));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatD_Type2)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 2nd feb");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20160202));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatD_Type3)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 4th feb 17");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20170204));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatD_Type4)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 4feb17");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, 20170204));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatD_Invalid)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 3th feb 17");
			Command* expected = new Command_Add(new Task("go home 3th", NO_DATE, 20160217));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatE_Type1)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home today");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, DATE));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatE_Type2)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home tmr");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, ADD_TO_DATE(1, DATE)));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatE_Type3)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home yesterday");
			Command* expected = new Command_Add(new Task("go home", NO_DATE, ADD_TO_DATE(-1, DATE)));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatE_Type4)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home next sunday");
			int daysToAdd = 14 - WEEK_DAY;
			Command* expected = new Command_Add(new Task("go home", NO_DATE, ADD_TO_DATE(daysToAdd, DATE)));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatE_Type5)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home sat");
			int daysToAdd = (13 - WEEK_DAY) % 7;
			if(daysToAdd == 0) {
				daysToAdd += 7;
			}
			Command* expected = new Command_Add(new Task("go home", NO_DATE, ADD_TO_DATE(daysToAdd, DATE)));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatE_Type6)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home next week");
			int daysToAdd = 14 - WEEK_DAY;
			if(daysToAdd == 7) {
				daysToAdd += 7;
			}
			Command* expected = new Command_Add(new Task("go home", NO_DATE, ADD_TO_DATE(daysToAdd, DATE)));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatE_Type7)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home this week");
			int daysToAdd = 7 - WEEK_DAY;
			if(daysToAdd == 0) {
				daysToAdd += 7;
			}
			Command* expected = new Command_Add(new Task("go home", NO_DATE, ADD_TO_DATE(daysToAdd, DATE)));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatE_Type8)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home this sun");
			int daysToAdd = 7 - WEEK_DAY;
			if(daysToAdd == 0) {
				daysToAdd += 7;
			}
			Command* expected = new Command_Add(new Task("go home", NO_DATE, ADD_TO_DATE(daysToAdd, DATE)));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatE_Invalid_Type1)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home week");
			Command* expected = new Command_Add(new Task("go home week"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateFormatE_Invalid_Type2)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home this today");
			Command* expected = new Command_Add(new Task("go home this", NO_DATE, DATE));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateRangeFormatA_Type1)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 3rd to 5th feb 17");
			Command* expected = new Command_Add(new Task("go home", 20170203, 20170205));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateRangeFormatA_Type2)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 5th to 3rd feb 17");
			Command* expected = new Command_Add(new Task("go home", 20170203, 20170205));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateRangeFormatA_Type3)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 5 to 3rd feb 17");
			Command* expected = new Command_Add(new Task("go home", 20170203, 20170205));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateRangeFormatA_Type4)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home 8pm 5th to 1000 3rd feb 17");
			Command* expected = new Command_Add(new Task("go home", 20170203, 20170205, 1000, 2000));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateRangeFormatB_Type1)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home feb 17th-19th");
			Command* expected = new Command_Add(new Task("go home", 20160217, 20160219));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateRangeFormatB_Type2)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home feb 19th-17th");
			Command* expected = new Command_Add(new Task("go home", 20160217, 20160219));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateRangeFormatB_Type3)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home feb 19th -17");
			Command* expected = new Command_Add(new Task("go home", 20160217, 20160219));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
		
		TEST_METHOD(Parser_DateRangeFormatB_Type4)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home feb 19th 2000hrs-17th 7 pm");
			Command* expected = new Command_Add(new Task("go home", 20160217, 20160219, 1900, 2000));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_DateRangeFormatB_Type5)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("go home feb 19th 2000hrs-17th 7 pm");
			Command* expected = new Command_Add(new Task("go home", 20160217, 20160219, 1900, 2000));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
	};

	TEST_CLASS(EditTest)
	{
	public:

		TEST_METHOD(Parser_Edit_Valid)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("edit 1 go home");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(1);
			Command* expected = new Command_Edit(intVector, new Task("go home", -2, -2, -2, -2, " ", -1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Edit_LastIndex)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("edit go home");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(0);
			Command* expected = new Command_Edit(intVector, new Task("go home", -2, -2, -2, -2, " ", -1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
        
		TEST_METHOD(Parser_Edit_Valid_NaturalLanguage)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("edit 1 to go home");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(1);
			Command* expected = new Command_Edit(intVector, new Task("go home", -2, -2, -2, -2, " ", -1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
        
		TEST_METHOD(Parser_Edit_LastIndex_NaturalLanguage)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("edit to go home");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(0);
			Command* expected = new Command_Edit(intVector, new Task("go home", -2, -2, -2, -2, " ", -1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Edit_Ambiguity)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("edit 1 apr");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(0);
			Command* expected = new Command_Edit(intVector, new Task("", -2, 20160401, -2, -2, " ", -1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

	};

	TEST_CLASS(ClearTest)
	{
	public:
		
		TEST_METHOD(Parser_Clear_All)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("clr");
			Command* expected = new Command_Clear(new vector<int>);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Clear_Invalid)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("clear your system of toxins");
			Command* expected = new Command_Add(new Task("clear your system of toxins"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Clear_All_NaturalLanguage)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("clr everytin");
			Command* expected = new Command_Clear(new vector<int>);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Clear_All_NaturalLanguage_Alternate)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("del everytin");
			Command* expected = new Command_Clear(new vector<int>);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Clear_Indexes)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("clr 1 2 3 4");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(1);
			intVector->push_back(2);
			intVector->push_back(3);
			intVector->push_back(4);
			Command* expected = new Command_Clear(intVector);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Clear_Indexes_Repeats)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("clr 1 2 3 4 2");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(1);
			intVector->push_back(3);
			intVector->push_back(4);
			intVector->push_back(2);
			Command* expected = new Command_Clear(intVector);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Clear_IndexRange)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("clr 1-4");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(1);
			intVector->push_back(2);
			intVector->push_back(3);
			intVector->push_back(4);
			Command* expected = new Command_Clear(intVector);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Clear_IndexRange_Repeats)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("clr 3 5 6 1 to 4");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(5);
			intVector->push_back(6);
			intVector->push_back(1);
			intVector->push_back(2);
			intVector->push_back(3);
			intVector->push_back(4);
			Command* expected = new Command_Clear(intVector);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Clear_AlternatePath)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("del 1 7 8 1 2");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(7);
			intVector->push_back(8);
			intVector->push_back(1);
			intVector->push_back(2);
			Command* expected = new Command_Clear(intVector);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Clear_MassParameter)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("del 1-5 location time");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(2);
			intVector->push_back(3);
			intVector->push_back(4);
			intVector->push_back(5);
			intVector->push_back(1);
			Command* expected = new Command_Edit(intVector, new Task("", -2, -2, -1, -1, "", -1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

	};

	TEST_CLASS(UndoTest)
	{
	public:
		
		TEST_METHOD(Parser_Undo_Valid)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("undo");
			Command* expected = new Command_Undo();
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Undo_Invalid)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("undo the calamities upon humanity");
			Command* expected = new Command_Add(new Task("undo the calamities upon humanity"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
	};

	TEST_CLASS(RedoTest)
	{
	public:
		
		TEST_METHOD(Parser_Redo_Valid)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("redo");
			Command* expected = new Command_Redo();
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Redo_Invalid)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("redo doMe.txt");
			Command* expected = new Command_Add(new Task("redo doMe.txt"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
	};

	TEST_CLASS(ScrollTest)
	{
	public:
		
		TEST_METHOD(Parser_Scroll_Valid)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("b");
			Command* expected = new Command_Scroll();
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Scroll_Invalid)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("scroll through this document");
			Command* expected = new Command_Add(new Task("scroll through this document"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
	};

	TEST_CLASS(HelpTest)
	{
	public:
		
		TEST_METHOD(Parser_Help_Valid)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("HELP");
			Command* expected = new Command_Help();
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Help_Valid2)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("?");
			Command* expected = new Command_Help();
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Help_Invalid)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("? the hell you looking at?");
			Command* expected = new Command_Add(new Task("? the hell you looking at?"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
	};

	TEST_CLASS(DeleteTest)
	{
	public:
		TEST_METHOD(Parser_Delete_Valid_LastIndex)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("d");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(0);
			Command* expected = new Command_Clear(intVector);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Delete_Valid)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("d 1");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(1);
			Command* expected = new Command_Clear(intVector);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Delete_Parameters)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("delete 1 -l -d -t");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(1);
			Command* expected = new Command_Edit(intVector, new Task("", -1, -1, -1, -1, "", -1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Delete_Parameters2)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("delete 1 -l -t");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(1);
			Command* expected = new Command_Edit(intVector, new Task("", -2, -2, -1, -1, "", -1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Delete_Parameters3)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("delete -t");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(0);
			Command* expected = new Command_Edit(intVector, new Task("", -2, -2, -1, -1, " ", -1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Delete_InValid)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("delete my browser history");
			Command* expected = new Command_Add(new Task("delete my browser history"));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}


	};
	
	TEST_CLASS(ChangeDirectoryTest)
	{
	public:
		TEST_METHOD(Parser_ChangeDirectory_Valid_Type1)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("cd c://blargh/whatdoesafolderaddressevenlooklike/lol");
			Command* expected = new Command_SaveDirectory("c://blargh/whatdoesafolderaddressevenlooklike/lol");
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ChangeDirectory_Valid_Type2)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("change directory c://blargh/whatdoesafolderaddressevenlooklike/lol");
			Command* expected = new Command_SaveDirectory("c://blargh/whatdoesafolderaddressevenlooklike/lol");
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ChangeDirectory_Default_Type1)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("change directory");
			Command* expected = new Command_SaveDirectory("");
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ChangeDirectory_Default_Type2)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("cd");
			Command* expected = new Command_SaveDirectory("");
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
	};

	TEST_CLASS(ChangeViewTypeTest)
	{
	public:
		
		TEST_METHOD(Parser_ChangeViewType_Valid_Type1)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("cv 2");
			Command* expected = new Command_ViewType(2);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ChangeViewType_Valid_Type2)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("change viewtype 2");
			Command* expected = new Command_ViewType(2);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ChangeViewType_Valid_Type3)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("view2");
			Command* expected = new Command_ViewType(2);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ChangeViewType_Valid_Type4)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("view present");
			Command* expected = new Command_ViewType(2);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ChangeViewType_Valid_Type5)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("view all");
			Command* expected = new Command_ViewType(1);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ChangeViewType_Valid_Type6)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("view tday");
			Command* expected = new Command_ViewType(3);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ChangeViewType_Valid_NaturalLanguage)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("change the viewtype to 2");
			Command* expected = new Command_ViewType(2);
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ChangeViewType_InValid_Type1)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("change view");
			Command* expected = new Command_Invalid();
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_ChangeViewType_InValid_Type2)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("cv");
			Command* expected = new Command_Invalid();
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
	};

	TEST_CLASS(SearchTest)
	{
	public:
		
		TEST_METHOD(Parser_Search_Valid)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("search water");
			Command* expected = new Command_Search("water");
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Search_Valid_NaturalLanguage)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("search for water");
			Command* expected = new Command_Search("water");
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Search_Valid_MultiWord)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("search for water in the sahara desert");
			Command* expected = new Command_Search("water in the sahara desert");
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Search_InValid)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("s");
			Command* expected = new Command_Invalid();
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
	};

	TEST_CLASS(MarkTest)
	{
	public:
		
		TEST_METHOD(Parser_Mark_LastIndex)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("done");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(0);
			Command* expected = new Command_Edit(intVector, new Task("", -2, -2, -2, -2, " ", 1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
		
		TEST_METHOD(Parser_Mark_LastIndex_notDone)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("not done");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(0);
			Command* expected = new Command_Edit(intVector, new Task("", -2, -2, -2, -2, " ", 0));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
        
		TEST_METHOD(Parser_Mark)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("1 done");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(1);
			Command* expected = new Command_Edit(intVector, new Task("", -2, -2, -2, -2, " ", 1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Mark_Range)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("1-3 done");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(1);
			intVector->push_back(2);
			intVector->push_back(3);
			Command* expected = new Command_Edit(intVector, new Task("", -2, -2, -2, -2, " ", 1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
        
		TEST_METHOD(Parser_Mark_Alternate)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("done 1");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(1);
			Command* expected = new Command_Edit(intVector, new Task("", -2, -2, -2, -2, " ", 1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Mark_Alternate_Range)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("done 1-3");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(1);
			intVector->push_back(2);
			intVector->push_back(3);
			Command* expected = new Command_Edit(intVector, new Task("", -2, -2, -2, -2, " ", 1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
        
		TEST_METHOD(Parser_Mark_NaturalLanguage_LastIndex)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("mark as done");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(0);
			Command* expected = new Command_Edit(intVector, new Task("", -2, -2, -2, -2, " ", 1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Mark_NaturalLanguage_LastIndex_notDone)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("mark as not done");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(0);
			Command* expected = new Command_Edit(intVector, new Task("", -2, -2, -2, -2, " ", 0));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
        
		TEST_METHOD(Parser_Mark_NaturalLanguage)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("mark 1 as done");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(1);
			Command* expected = new Command_Edit(intVector, new Task("", -2, -2, -2, -2, " ", 1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}

		TEST_METHOD(Parser_Mark_NaturalLanguage_Range)
		{
			Parser* sut = Parser::getInstance();
			Command* actual = sut->parse("mark 1-3 as done");
			vector<int>* intVector = new vector<int>;
			intVector->push_back(1);
			intVector->push_back(2);
			intVector->push_back(3);
			Command* expected = new Command_Edit(intVector, new Task("", -2, -2, -2, -2, " ", 1));
			Assert::AreEqual(expected->getStringForm(),actual->getStringForm());
		}
        
	};
}
```
