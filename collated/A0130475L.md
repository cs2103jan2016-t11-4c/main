# A0130475L
###### doMe\CommandFeedback.cpp
``` cpp
#include "CommandFeedback.h"

const string CommandFeedback::DEFAULT_TEXT_FILE_NAME = "doMe.txt";
const string CommandFeedback::MESSAGE_VOID_STRING = "";
const string CommandFeedback::MESSAGE_TASK_INDEX = ", ";

const string CommandFeedback::MESSAGE_ADD = "Added \"%s\" into %s";
const string CommandFeedback::MESSAGE_DELETE = "Deleted \"%s\" from %s";
const string CommandFeedback::MESSAGE_DELETE_MULTIPLE = "Deleted tasks \"%s\" from %s";
const string CommandFeedback::MESSAGE_EDIT = "Editted task to \"%s\".";
const string CommandFeedback::MESSAGE_EDIT_DONE = "Marked \"%s\" as DONE.";
const string CommandFeedback::MESSAGE_EDIT_UNDONE = "Marked \"%s\" as UNDONE.";
const string CommandFeedback::MESSAGE_CLEAR = "All tasks in view cleared.";
const string CommandFeedback::MESSAGE_SEARCH = "~Showing all results for \"%s\". Type \"exit\" to exit the search module~";
const string CommandFeedback::MESSAGE_CHANGE_FILE_DIRECTORY = "Save Directory changed to %s";
const string CommandFeedback::MESSAGE_DEFAULT_FILE_DIRECTORY = "Save directory changed to <Default Directory>";
const string CommandFeedback::MESSAGE_VIEW_TYPE = "Viewtype has been changed to (%d).";
const string CommandFeedback::MESSAGE_EXIT_SEARCH = "Exited SEARCH module.";
const string CommandFeedback::MESSAGE_EXIT_HELP = "Exited HELP module.";
const string CommandFeedback::MESSAGE_REDO = "Redo <%s>.";

const string CommandFeedback::ERROR_INVALID_ADD = "Invalid (ADD) command been inputted.";
const string CommandFeedback::ERROR_INVALID_DELETE = "Invalid (DELETE) command has been entered.";
const string CommandFeedback::ERROR_INVALID_COMMAND_FORMAT = "Invalid command format has been entered.";
const string CommandFeedback::ERROR_INVALID_COMMAND = "Invalid command has been entered.";
const string CommandFeedback::ERROR_INVALID_VIEWTYPE = "Invalid (Viewtype) has been entered.";
const string CommandFeedback::ERROR_INVALID_EDIT = "Invalid (EDIT) command has been entered.";
const string CommandFeedback::ERROR_INVALID_UNDO = "No UNDOs found.";
const string CommandFeedback::ERROR_INVALID_REDO = "No REDOs found.";
const string CommandFeedback::ERROR_INVALID_SAVE_FILE_DIRECTORY = "Invalid directory has been entered.";


const string CommandFeedback::MESSAGE_UNDO_COMMAND = "Previous command undone.";
const string CommandFeedback::MESSAGE_UNDO_ADD = "Undid (ADD) of \"%s\".";
const string CommandFeedback::MESSAGE_UNDO_DELETE = "Undid (DELETE) of \"%s\".";
const string CommandFeedback::MESSAGE_UNDO_EDIT = "Undid (EDIT) of \"%s\".";
const string CommandFeedback::MESSAGE_UNDO_EDIT_DONE = "Undid (DONE) of \"%s\".";
const string CommandFeedback::MESSAGE_UNDO_EDIT_UNDONE = "Undid (UNDONE) of \"%s\".";
const string CommandFeedback::MESSAGE_UNDO_CLEAR = "Undid (CLEAR).";
const string CommandFeedback::MESSAGE_UNDO_VIEW_TYPE = "Undid (Viewtype) change of \"%d\".";
const string CommandFeedback::MESSAGE_UNDO_CHANGE_DIRECTORY = "Undid (Change Directory) of \"%s\".";

CommandFeedback* CommandFeedback::_instance = 0;

CommandFeedback* CommandFeedback::getInstance() {
    if (_instance == 0) {
        _instance = new CommandFeedback;
    }
    return _instance;
}

CommandFeedback::CommandFeedback(void) {
}

CommandFeedback::~CommandFeedback(void) {
}

/****************************************************************/

string CommandFeedback::getTaskString(Task* task, int viewType) {
    ViewType* taskListType;

    switch(viewType) {
    case 1:
        taskListType = new ViewType1();
        break;
    case 2:
        taskListType = new ViewType2();
        break;
    case 3:
        taskListType = new ViewType3();
        break;
    default:
        taskListType = new ViewType0();
        break;
    }

    return taskListType->getTaskString(task);
}

string CommandFeedback::getCommandFeedback(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    CommandType commandType = executionMessage->getCommandType();

    switch(commandType) {
    case ADD:
        return getNotificationAdd(executionMessage, commandOutcome, viewType);
        break;
    case DISPLAY:
        break;
    case DEL:
        return getNotificationDelete(executionMessage, commandOutcome, viewType);
        break;
    case EDIT:
        return getNotificationEdit(executionMessage, commandOutcome, viewType);
        break;
    case CLEAR:
        return getNotificationClear(executionMessage, commandOutcome, viewType);
        break;
    case UNDO:
        return getNotificationUndo(executionMessage, commandOutcome, viewType);
        break;
    case REDO:
        return getNotificationRedo(executionMessage, commandOutcome, viewType);
        break;
    case SORT:
        break;
    case SEARCH:
        return getNotificationSearchTerm(executionMessage, commandOutcome, viewType);
        break;
    case ENDSEARCH:
        return getNotificationEndSearch(executionMessage, commandOutcome, viewType);
        break;
    case VIEWTYPE:
        return getNotificationViewType(executionMessage, commandOutcome, viewType);
        break;
    case SAVEDIRECTORY:
        return getNotificationChangeSaveFileDirectory(executionMessage, commandOutcome, viewType);
        break;
    case EXIT:
        break;
    case HELP:
        return getNotificationHelpPrompt(executionMessage, commandOutcome, viewType);
        break;
    case INVALID:
        return getNotificationInvalidCommand(executionMessage, commandOutcome, viewType);
        break;
    case SCROLL:
        throw Exception_CommandScroll();
        break;        
    default:
        break;
    }
    return MESSAGE_VOID_STRING;
}

/****************************************************************/

string CommandFeedback::getNotificationUndo(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    Command* undoCommandMessage;
    CommandType commandType;

    switch(commandOutcome) {
    case VALID_MESSAGE:
        undoCommandMessage = executionMessage->getUndoneCommand();
        commandType = undoCommandMessage->getCommandType();
        switch(commandType) {
        case ADD:
            return undoNotificationAdd(undoCommandMessage, viewType);
            break;
        case DISPLAY:
            assert(0);
            break;
        case DEL:
            return undoNotificationDel(undoCommandMessage, viewType);
            break;
        case EDIT:
            return undoNotificationEdit(undoCommandMessage, viewType);
            break;
        case CLEAR:
            return undoNotificationClear(undoCommandMessage, viewType);
            break;
        case UNDO:
            assert(0);
            break;
        case SORT:
            assert(0);
            break;
        case SEARCH:
            return validNotificationExitSearch();
            break;
        case ENDSEARCH:
            return getNotificationSearchTerm(undoCommandMessage, commandOutcome, viewType);
            break;
        case VIEWTYPE:
            return undoNotificationViewType(undoCommandMessage, viewType);
            break;
        case SAVEDIRECTORY:
            return undoNotificationChangDirectory(undoCommandMessage, viewType);
            break;
        case EXIT:
            assert(0);
            break;
        case INVALID:
            return invalidNotificationUndo();
            break;
        }
    case INVALID_MESSAGE:
        return invalidNotificationUndo();
        break;
    }
    return MESSAGE_UNDO_COMMAND;
}

string CommandFeedback::getNotificationRedo(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    string redoString;

    switch(commandOutcome) {
    case VALID_MESSAGE:
        redoString = getCommandFeedback(executionMessage->getRedoneCommand(), commandOutcome, viewType);
        return validNotificationRedo(redoString);
        break;
    case INVALID_MESSAGE:
        return invalidNotificationRedo();
        break;
    }
    return ERROR_INVALID_COMMAND;
}

string CommandFeedback::getNotificationAdd(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    switch(commandOutcome) {
    case VALID_MESSAGE:
        return validNotificationAdd(executionMessage->getTask(), viewType, DEFAULT_TEXT_FILE_NAME);
        break;
    case INVALID_MESSAGE:
        return invalidNotificationAdd();
        break;
    }
    return ERROR_INVALID_COMMAND;
}

string CommandFeedback::getNotificationDelete(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    vector<int>* deleteList;
    switch(commandOutcome) {
    case VALID_MESSAGE:
        deleteList = executionMessage->getDeleteList();
        if(deleteList->size() > 1) {
            return validNotificationDeleteMultiple(deleteList, viewType, DEFAULT_TEXT_FILE_NAME);
        } else {
            return validNotificationDelete(executionMessage->getTask(), viewType, DEFAULT_TEXT_FILE_NAME);
        }
        break;
    case INVALID_MESSAGE:
        return invalidNotificationDelete();
        break;
    }
    return ERROR_INVALID_COMMAND;
}

string CommandFeedback::getNotificationEdit(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    switch(commandOutcome) {
    case VALID_MESSAGE:
        return validNotificationEdit(executionMessage->getTask(), viewType, executionMessage->getDoneStatus());
        break;
    case INVALID_MESSAGE:
        return invalidNotificationEdit();
        break;
    }
    return ERROR_INVALID_COMMAND;
}

string CommandFeedback::getNotificationClear(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    switch(commandOutcome) {
    case VALID_MESSAGE:
        return validNotificationClear(DEFAULT_TEXT_FILE_NAME);
        break;
    case INVALID_MESSAGE:
        return ERROR_INVALID_COMMAND;
        break;
    }
    return ERROR_INVALID_COMMAND;
}

string CommandFeedback::getNotificationSearchTerm(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    string searchTerm;
    searchTerm = executionMessage->getSearchTerm();
    return validNotificationSearchTerm(searchTerm);
}

string CommandFeedback::getNotificationEndSearch(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    switch(commandOutcome) {
    case VALID_MESSAGE:
        return validNotificationExitSearch();
        break;
    case INVALID_MESSAGE:
        return ERROR_INVALID_COMMAND;
        break;
    }
    return ERROR_INVALID_COMMAND;
}

string CommandFeedback::getNotificationViewType(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    switch(commandOutcome) {
    case VALID_MESSAGE:
        return validNotificationViewType(executionMessage->getViewType());
        break;
    case INVALID_MESSAGE:
        return invalidNotificationViewtype();
        break;
    }
    return ERROR_INVALID_COMMAND;
}

string CommandFeedback::getNotificationChangeSaveFileDirectory(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    switch(commandOutcome) {
    case VALID_MESSAGE:
        return validNotificationChangeSaveFileDirectory(executionMessage->getSaveDirectory());
        break;
    case INVALID_MESSAGE:
        return invalidNotificationSaveFileDirectory();
        break;
    }
    return ERROR_INVALID_COMMAND;
}

string CommandFeedback::getNotificationHelpPrompt(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    return validNotificationHelpPrompt();
}

string CommandFeedback::getNotificationInvalidCommand(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    return invalidNotificationCommand();
}

/****************************************************************/

string CommandFeedback::validNotificationAdd(Task* task, int viewType, string textFileName) {
    string taskString;
    taskString = getTaskString(task,viewType);
    sprintf_s(buffer, MESSAGE_ADD.c_str(),taskString.c_str(), textFileName.c_str());
    return buffer;
}

string CommandFeedback::validNotificationDelete(Task* task, int viewType, string textFileName) {
    string taskString;
    taskString = getTaskString(task,viewType);
    sprintf_s(buffer, MESSAGE_DELETE.c_str(),taskString.c_str(), textFileName.c_str());
    return buffer;
}

string CommandFeedback::validNotificationDeleteMultiple(vector<int>* deleteIndex, int viewType, string textFileName) {
    string taskString;
    vector<int>::iterator intIter = deleteIndex->begin();
    while(intIter != deleteIndex->end()) {
        taskString = taskString + taskIndexToString(*intIter);
        intIter++;
    }
    sprintf_s(buffer, MESSAGE_DELETE_MULTIPLE.c_str(), taskString.c_str(), textFileName.c_str());
    return buffer;
}

string CommandFeedback::validNotificationEdit(Task* task, int viewType, int doneStatus) {
    string taskString;
    taskString = getTaskString(task,viewType);
    if(doneStatus == 1) {
        sprintf_s(buffer, MESSAGE_EDIT_DONE.c_str(),taskString.c_str());
    } else {
        if(doneStatus == -1) {
            sprintf_s(buffer, MESSAGE_EDIT.c_str(),taskString.c_str());
        } else {
            sprintf_s(buffer, MESSAGE_EDIT_UNDONE.c_str(),taskString.c_str());
        }
    }
    return buffer;
}

string CommandFeedback::validNotificationClear(string textFileName) {
    return MESSAGE_CLEAR;
}

string CommandFeedback::validNotificationSearchTerm(string searchTerm) {
    sprintf_s(buffer, MESSAGE_SEARCH.c_str(), searchTerm.c_str());
    return buffer;
}

string CommandFeedback::validNotificationExitSearch() {
    sprintf_s(buffer, MESSAGE_EXIT_SEARCH.c_str());
    return buffer;
}

string CommandFeedback::validNotificationViewType(int newViewType) {
    sprintf_s(buffer, MESSAGE_VIEW_TYPE.c_str(), newViewType);
    return buffer;
}

string CommandFeedback::validNotificationChangeSaveFileDirectory(string newDirectory) {
    if(newDirectory.empty()) {
        return MESSAGE_DEFAULT_FILE_DIRECTORY;
    } else {
        sprintf_s(buffer, MESSAGE_CHANGE_FILE_DIRECTORY.c_str(), newDirectory.c_str());
        return buffer;
    }

}

string CommandFeedback::validNotificationHelpPrompt() {
    return MESSAGE_EXIT_HELP;
}

string CommandFeedback::validNotificationRedo(string redoString) {
    sprintf_s(buffer, MESSAGE_REDO.c_str(),redoString.c_str());
    return buffer;
}

/****************************************************************/

string CommandFeedback::invalidNotificationAdd() {
    return ERROR_INVALID_ADD;
}

string CommandFeedback::invalidNotificationDelete() {
    return ERROR_INVALID_DELETE;
}

string CommandFeedback::invalidNotificationEdit() {
    return ERROR_INVALID_EDIT;
}

string CommandFeedback::invalidNotificationViewtype() {
    return ERROR_INVALID_VIEWTYPE;
}

string CommandFeedback::invalidNotificationSaveFileDirectory() {
    return ERROR_INVALID_SAVE_FILE_DIRECTORY;
}

string CommandFeedback::invalidNotificationCommand() {
    return ERROR_INVALID_COMMAND;
}

string CommandFeedback::invalidNotificationUndo() {
    return ERROR_INVALID_UNDO;
}

string CommandFeedback::invalidNotificationRedo() {
    return ERROR_INVALID_REDO;
}

/****************************************************************/

string CommandFeedback::undoNotificationAdd(Command* executionMessage, int viewType) {
    string taskString;
    taskString = getTaskString(executionMessage->getTask(), viewType);
    sprintf_s(buffer, MESSAGE_UNDO_ADD.c_str(),taskString.c_str());
    return buffer;
}

string CommandFeedback::undoNotificationDel(Command* executionMessage, int viewType) {
    string taskString;
    taskString = getTaskString(executionMessage->getTask(), viewType);
    sprintf_s(buffer, MESSAGE_UNDO_DELETE.c_str(),taskString.c_str());
    return buffer;
}

string CommandFeedback::undoNotificationEdit(Command* executionMessage, int viewType) {
    string taskString;
    int doneStatus = executionMessage->getDoneStatus();
    switch(doneStatus) {
    case -1:
        taskString = getTaskString(executionMessage->getTask(), viewType);
        sprintf_s(buffer, MESSAGE_UNDO_EDIT.c_str(),taskString.c_str());
        return buffer;
        break;
    case 0:
        taskString = getTaskString(executionMessage->getTask(), viewType);
        sprintf_s(buffer, MESSAGE_UNDO_EDIT_UNDONE.c_str(),taskString.c_str());
        return buffer;
        break;
    case 1:
        taskString = getTaskString(executionMessage->getTask(), viewType);
        sprintf_s(buffer, MESSAGE_UNDO_EDIT_DONE.c_str(),taskString.c_str());
        return buffer;
        break;
    default:
        return MESSAGE_VOID_STRING;
    }

}

string CommandFeedback::undoNotificationClear(Command* executionMessage, int viewType) {
    return MESSAGE_UNDO_CLEAR;
}

string CommandFeedback::undoNotificationViewType(Command* executionMessage, int viewType) {
    sprintf_s(buffer, MESSAGE_UNDO_VIEW_TYPE.c_str(),executionMessage->getViewType());
    return buffer;
}

string CommandFeedback::undoNotificationChangDirectory(Command* executionMessage, int viewType) {
    sprintf_s(buffer, MESSAGE_UNDO_CHANGE_DIRECTORY.c_str(),executionMessage->getSaveDirectory());
    return buffer;
}

/****************************************************************/
string CommandFeedback::taskIndexToString(int index) {
    ostringstream oss;
    oss << index;  
    string indexString = oss.str();

    return indexString + MESSAGE_TASK_INDEX;
}
```
###### doMe\CommandFeedback.h
``` h
#pragma once
#include <string>

#include "Exception_CommandScroll.h"
#include "Command.h"
#include "Task.h"
#include "ViewType.h"
#include "ViewType0.h"
#include "ViewType1.h"
#include "ViewType2.h"
#include "ViewType3.h"

using namespace std;

enum CommandOutcome {
    VALID_MESSAGE, INVALID_MESSAGE
};

class CommandFeedback {
public:
    ~CommandFeedback(void);
    static CommandFeedback* getInstance();
    string getCommandFeedback(Command* executionMessage, CommandOutcome commandOutcome, int viewType);
#ifndef TESTMODE 
private: 
#else 
public: 
#endif
    static CommandFeedback* _instance;
    char buffer[255];
    CommandFeedback(void);

    string getTaskString(Task* task, int viewType); 

    //get string for individual commands
    string getNotificationUndo(Command* executionMessage, CommandOutcome commandOutcome, int viewType);
    string getNotificationRedo(Command* executionMessage, CommandOutcome commandOutcome, int viewType);

    string getNotificationAdd(Command* executionMessage, CommandOutcome commandOutcome, int viewType);
    string getNotificationDelete(Command* executionMessage, CommandOutcome commandOutcome, int viewType);
    string getNotificationEdit(Command* executionMessage, CommandOutcome commandOutcome, int viewType);
    string getNotificationClear(Command* executionMessage, CommandOutcome commandOutcome, int viewType);
    string getNotificationSearchTerm(Command* executionMessage, CommandOutcome commandOutcome, int viewType);
    string getNotificationEndSearch(Command* executionMessage, CommandOutcome commandOutcome, int viewType);
    string getNotificationViewType(Command* executionMessage, CommandOutcome commandOutcome, int viewType);
    string getNotificationChangeSaveFileDirectory(Command* executionMessage, CommandOutcome commandOutcome, int viewType);
    string getNotificationHelpPrompt(Command* executionMessage, CommandOutcome commandOutcome, int viewType);
    string getNotificationInvalidCommand(Command* executionMessage, CommandOutcome commandOutcome, int viewType);

    //valid notification
    string validNotificationAdd(Task* task, int viewType, string textFileName); 
    string validNotificationDelete(Task* task, int viewType, string textFileName);
    string validNotificationDeleteMultiple(vector<int>* deleteIndex, int viewType, string textFileName);
    string validNotificationEdit(Task* task, int viewType, int doneStatus);
    string validNotificationClear(string textFileName);
    string validNotificationSearchTerm(string searchTerm);
    string validNotificationExitSearch(); 
    string validNotificationViewType(int newViewType);
    string validNotificationChangeSaveFileDirectory(string newDirectory);
    string validNotificationHelpPrompt();
    string validNotificationRedo(string redoString);

    //Invalid notification
    string invalidNotificationCommand();
    string invalidNotificationAdd();
    string invalidNotificationEdit(); 
    string invalidNotificationDelete();
    string invalidNotificationViewtype();
    string invalidNotificationSaveFileDirectory();
    string invalidNotificationUndo();
    string invalidNotificationRedo();


    //undo notification
    string undoNotificationAdd(Command* executionMessage, int viewType);
    string undoNotificationDel(Command* executionMessage, int viewType);
    string undoNotificationEdit(Command* executionMessage, int viewType);
    string undoNotificationClear(Command* executionMessage, int viewType);
    string undoNotificationViewType(Command* executionMessage, int viewType);
    string undoNotificationChangDirectory(Command* executionMessage, int viewType);

    //helper function
    string taskIndexToString(int index);

    static const string DEFAULT_TEXT_FILE_NAME;
    static const string MESSAGE_VOID_STRING;
    static const string MESSAGE_TASK_INDEX;

    static const string MESSAGE_ADD;
    static const string MESSAGE_DELETE;
    static const string MESSAGE_DELETE_MULTIPLE;
    static const string MESSAGE_EDIT;
    static const string MESSAGE_EDIT_DONE;
    static const string MESSAGE_EDIT_UNDONE;
    static const string MESSAGE_CLEAR;
    static const string MESSAGE_SEARCH;
    static const string MESSAGE_EXIT_SEARCH;
    static const string MESSAGE_VIEW_TYPE;
    static const string MESSAGE_CHANGE_FILE_DIRECTORY;
    static const string MESSAGE_DEFAULT_FILE_DIRECTORY;
    static const string MESSAGE_EXIT_HELP;
    static const string MESSAGE_REDO;

    static const string ERROR_INVALID_ADD;
    static const string ERROR_INVALID_DELETE;
    static const string ERROR_INVALID_COMMAND_FORMAT;
    static const string ERROR_INVALID_COMMAND;
    static const string ERROR_INVALID_VIEWTYPE;
    static const string ERROR_INVALID_EDIT;
    static const string ERROR_INVALID_UNDO;
    static const string ERROR_INVALID_SAVE_FILE_DIRECTORY;
    static const string ERROR_INVALID_REDO;

    static const string MESSAGE_UNDO_COMMAND;
    static const string MESSAGE_UNDO_ADD;
    static const string MESSAGE_UNDO_DELETE;
    static const string MESSAGE_UNDO_EDIT;
    static const string MESSAGE_UNDO_EDIT_DONE;
    static const string MESSAGE_UNDO_EDIT_UNDONE;
    static const string MESSAGE_UNDO_CLEAR;
    static const string MESSAGE_UNDO_VIEW_TYPE;
    static const string MESSAGE_UNDO_CHANGE_DIRECTORY;
};
```
###### doMe\Exception_CommandScroll.cpp
``` cpp
#include "Exception_CommandScroll.h"

const string Exception_CommandScroll::SCROLL_MESSAGES = "Press \"Up/Down/PgUp/PgDw\" to move page up and down. Press any other key to exit";

Exception_CommandScroll::Exception_CommandScroll(void) {
}

Exception_CommandScroll::~Exception_CommandScroll(void) {
}

string Exception_CommandScroll::getString() {
    return SCROLL_MESSAGES;
}
```
###### doMe\Exception_CommandScroll.h
``` h
#pragma once
#include <string>

using namespace std;

class Exception_CommandScroll {
private:
    static const string SCROLL_MESSAGES;
public:
    Exception_CommandScroll(void);
    ~Exception_CommandScroll(void);
    string getString();
};



```
###### doMe\Exception_FirstTimeUser.cpp
``` cpp
#include "Exception_FirstTimeUser.h"

Exception_FirstTimeUser::Exception_FirstTimeUser(void) {
}

Exception_FirstTimeUser::~Exception_FirstTimeUser(void) {
}
```
###### doMe\Exception_FirstTimeUser.h
``` h
#pragma once

using namespace std;

class Exception_FirstTimeUser {
public:
    Exception_FirstTimeUser(void);
    ~Exception_FirstTimeUser(void);
};

```
###### doMe\Settings.cpp
``` cpp
#include "Settings.h"
const string Settings::FILE_SETTINGS_NAME = "doMeSettings.txt";
const string Settings::DEFAULT_TEXT_FILE_NAME = "doMe.txt";
const int Settings::DEFAULT_VIEWTYPE = 1;
const int Settings::DEFAULT_WINDOWS_WIDTH = 80;
const int Settings::DEFAULT_WINDOWS_LENGTH = 35; 

Settings* Settings::_instance = 0;

Settings* Settings::getInstance() {
    if (_instance == 0) {
        _instance = new Settings;
    }
    return _instance;
}

Settings::Settings(void) {
    _textFileName = DEFAULT_TEXT_FILE_NAME;
    _viewType = DEFAULT_VIEWTYPE;
    _width = DEFAULT_WINDOWS_WIDTH;
    _length = DEFAULT_WINDOWS_LENGTH;
}

Settings::~Settings(void) {
}

/****************************************************************/

void Settings::loadSettings() {
    Storage* storage;
    storage = Storage::getInstance();
    try {
        ifstream readFile(FILE_SETTINGS_NAME);
        if(readFile.is_open()) {
            settingsLoadVector(storage->retrieveData(FILE_SETTINGS_NAME));
        } else {
            saveSettings();
            throw Exception_FirstTimeUser();
        }
    } catch (Exception_FileCannotOpen e) {
        saveSettings();
    }
}

void Settings::saveSettings() {
    Storage* storage;
    storage = Storage::getInstance();
    storage->saveData(settingsGetVector() ,FILE_SETTINGS_NAME);
}

/****************************************************************/

void Settings::settingsLoadVector(vector<string> &existingData) {
    int i = 0;

    _textFileName = existingData[i];
    _saveDirectory = existingData[i+1];
    _viewType = stringToInteger(existingData[i+2]);
    _width = stringToInteger(existingData[i+3]);
    _length = stringToInteger(existingData[i+4]);

}

vector<string> Settings::settingsGetVector() {
    vector<string> updatedData;

    updatedData.push_back(_textFileName);
    updatedData.push_back(_saveDirectory);
    updatedData.push_back(integerToString(_viewType));
    updatedData.push_back(integerToString(_width));
    updatedData.push_back(integerToString(_length));
    return updatedData;
}

/****************************************************************/

bool Settings::changeSaveDirectory(string directory) {
    string newDirectory;
    newDirectory = createValidFileDirectoryString(directory);
    if(directory.empty()) {
        _saveDirectory = directory;
        return true;
    }
    if(checkValidityOfDirectory(newDirectory)) {
        _saveDirectory = newDirectory;
        saveSettings(); //adding saveSettings() to all setter functions in Settings class; some redundancy may need further refactoring -joan
        return true;   
    } else {
        return false;
    }
}

bool Settings::changeViewType(int newViewType) {
    if((newViewType >= 0) && (newViewType <= 3)) {
        _viewType = newViewType;
        saveSettings(); //adding saveSettings() to all setter functions in Settings class; some redundancy may need further refactoring -joan
        return true;
    } else {
        return false;
    }
}

void Settings::changeWindowSize(int column, int row) {
    _width = column;
    _length = row;
    saveSettings();
}

/****************************************************************/

string Settings::getSaveDirectory() {
    return (_saveDirectory /*+ _textFileName*/);   //getSaveDirectory() should return the main directory w/o specific txt filename so that 
    //it can be generalised for settings.txt & doMe.txt & logs.txt etc etc
    //pre-condition: all these .txt files must be in same directory
}

int Settings::getViewType() {
    return _viewType;
}

string Settings::getTextFileName() {
    return _textFileName;
}

void Settings::getWindowSize(int& width, int& length) {
    width = _width;
    length = _length;
}

/****************************************************************/

string Settings::integerToString(int integer) {
    ostringstream word;
    word << integer;
    return word.str();
}

int Settings::stringToInteger(string& text) {
    stringstream ss(text);
    int integer;

    ss >> integer;

    return integer;
}

/****************************************************************/

//helper function to make correct format of save directory
string Settings::createValidFileDirectoryString(string directory) {
    string fileSeparator= "\\";
    if(directory.find_last_of("\\")+1 == directory.size()) {
        return directory;
    } else {
        return directory + fileSeparator;
    }
}

//https://msdn.microsoft.com/en-us/library/windows/desktop/bb773584(v=vs.85).aspx
bool Settings::checkValidityOfDirectory(const string& directory) {
    DWORD ftyp = GetFileAttributesA(directory.c_str());
    if (ftyp == INVALID_FILE_ATTRIBUTES) {
        return false;  
    }
    if (ftyp & FILE_ATTRIBUTE_DIRECTORY) {
        return true;   
    }

    return false;    
}
```
###### doMe\Settings.h
``` h
#pragma once
#include <string>
#include <fstream>
#include <iostream>
#include <sstream>
#include <windows.h>
#include "Storage.h"
#include "Exception_FirstTimeUser.h"
using namespace std;


class Settings {
public:
    static Settings* getInstance();

    //setter
    bool changeSaveDirectory(string directory); //API for Memory component
    bool changeViewType(int newViewType); //API for Memory compoent
    void changeWindowSize(int column, int row);
    //getter
    string getSaveDirectory();
    string getTextFileName();
    int getViewType();
    void getWindowSize(int& width, int& length);

    void loadSettings(); //placed in constructor of Settings; boolean return value to be reconsidered

#ifndef TESTMODE 
private: 
#else 
public: 
#endif

    static const string FILE_SETTINGS_NAME;
    static const string DEFAULT_TEXT_FILE_NAME;
    static const string SYSTEM_MODE_CON;
    static const int DEFAULT_VIEWTYPE;
    static const int DEFAULT_WINDOWS_WIDTH;
    static const int DEFAULT_WINDOWS_LENGTH; 

    static Settings* _instance;
    string _textFileName;
    string _saveDirectory;
    int _viewType; 
    int _width;
    int _length;
    char buffer[255];

    Settings(void);
    ~Settings(void);

    void settingsLoadVector(vector<string> &existingData);
    vector<string> settingsGetVector();

    string createValidFileDirectoryString(string directory); //helper input return directory with "/"
    bool checkValidityOfDirectory(const string& directory); //might remove

    string integerToString(int integer);
    int stringToInteger(string& text);

    void saveSettings(); //placed in every setter function, in order save changes to settings.txt	

};

```
###### doMe\UserInterface.cpp
``` cpp
#include "UserInterface.h"

const string UserInterface::SYSTEM_MODE_CON = "mode CON: COLS=%d lines=%d";
const string UserInterface::SYSTEM_COLOUR = "Color 0F";
const char UserInterface::MESSAGE_BOX_CHARACTER = '=';
const string UserInterface::MESSAGE_VOID_STRING = "";
const string UserInterface::MESSAGE_WELCOME = "Welcome to doMe. Your programme is ready for use.";
unsigned int UserInterface::DISPLAY_WIDTH;
unsigned int UserInterface::DISPLAY_LENGTH;
unsigned int UserInterface::DISPLAY_BOX_WIDTH;
unsigned int UserInterface::DISPLAY_BOX_LENGTH;
const int UserInterface::DISPLAY_DEFAULT_WIDTH = 80;
const int UserInterface::DISPLAY_DEFAULT_LENGTH = 25;
const int UserInterface::DISPLAY_SYNC_WIDTH = 0;
const int UserInterface::DISPLAY_SYNC_LENGTH = 7;

const string UserInterface::MESSAGE_COMMAND_PROMPT = "command: ";
const string UserInterface::MESSAGE_SCROLL_PROMPT = "scroll: ";
const string UserInterface::MESSAGE_SCROLL_EXIT = "Exited Scroll Engine";
const string UserInterface::MESSAGE_DEFAULT_DIRECTORY = "Default Directory";
const string UserInterface::MESSAGE_DIRECTORY_BOX = "<%s>";

const string UserInterface::MESSAGE_VIEWTYPE_0 = "[View: CORE]";
const string UserInterface::MESSAGE_VIEWTYPE_1 = "[View: ALL]";
const string UserInterface::MESSAGE_VIEWTYPE_2 = "[View: PRESENT]";
const string UserInterface::MESSAGE_VIEWTYPE_3 = "[View: TODAY]";

const string UserInterface::COLOUR_DEFAULT = "DEFAULT";
const string UserInterface::COLOUR_NEW = "NEW";
const string UserInterface::COLOUR_DONE = "DONE";
const string UserInterface::COLOUR_SEARCH = "SEARCH";
const string UserInterface::COLOUR_HELP = "HELP";
const string UserInterface::COLOUR_CATEGORY = "CATEGORY";
const string UserInterface::COLOUR_FEEDBACK = "FEEDBACK";
const string UserInterface::COLOUR_VIEW_INDICATOR = "VIEW";
const string UserInterface::COLOUR_SCROLL = "SCROLL";

const string UserInterface::MESSAGE_WELCOME_SCREEN[] = {
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "                                  Welcome to",
    "                     _         __  __                          ",
    "                    | |       |  \\/  |                         ",
    "                  __| |  ___  | \\  / |  ___     ___ __  __ ___ ",
    "                 / _` | / _ \\ | |\\/| | / _ \\   / _ \\  \\/ // _ \\",
    "                | (_| || (_) || |  | ||  __/ _|  __/ >  <|  __/",
    "                 \\__,_| \\___/ |_|  |_| \\___|(_)\\___|/_/\\_\\___|",
    "",
    "                         <Press any key to continue>",
    "",
    "", 
    "", 
    "", 
    "", 
    "", 
    "", 
    "", 
    "",
};

const string UserInterface::MESSAGE_HELP_TIPS[] = {
    "",
    "",
    "===============================================================================",
    "                            List of Available Commands",
    "",
    "                            PRESS ANY KEY TO CONTINUE...",
    "                          (Arrow Keys/PgUp PgDn to Scroll)",
    "===============================================================================",
    "",
    "                                  _   ___  ___  ",
    "                                 /_\\ |   \\|   \\ ",
    "                                / _ \\| |) | |) |",
    "                               /_/ \\_\\___/|___/  eg. \"Jog tmr 6am @the park\"",
    "                            +-----------------------------------------------+",
    "                            |              OPTIONAL PARAMETERS              |",
    "   +----------+-------------+--------------------+--------------+-----------+",
    "   | MODIFIER | TASK NAME   | DATE               | TIME         | LOCATION  |",
    "   +----------+-------------+--------------------+--------------+-----------+",
    "   | <empty>  | Cycling     | 14/02/2016         | 1430         | @Florist  |",
    "   | add      | Buy flowers | 14/02/16           | 14.30        | @the park |",
    "   | a        | *tuesday    | 14/02              | 14:30        |           |",
    "   |          |             | 14 Feb             | 11am         |           |",
    "   |          |             | 14 Feb to 16 Feb   | 1430pm       |           |",
    "   |          |             | 14 Feb - 16 Feb    |              |           |",
    "   |          |             | 14 - 16 Feb        | 1100 to 1430 |           |",
    "   |          |             |                    | 1100 - 1430  |           |",
    "   |          |             | today              | 11am - 230pm |           |",
    "   |          |             | tmr, tomorrow      | 11 - 230pm   |           |",
    "   |          |             | mon, monday...     |              |           |",
    "   |          |             | next tuesday       |              |           |",
    "   |          |             | mon to wed         |              |           |",
    "   |          |             | mon - wed          |              |           |",
    "   |          |             | this/next week     |              |           |",
    "   +----------+-------------+--------------------+--------------+-----------+",
    "  - Optional parameters can be typed in any order eg.\"cycling 7pm @park today\".",
    "  - Asterisks turn keywords into normal text eg.\"thank god its *friday\"",
    "  - \"this week\" sets the deadline to be the end of the week, Sunday.",
    "",
    "          ============================================================",
    "",
    "                          ___  ___ _    ___ _____ ___ ",
    "                         |   \\| __| |  | __|_   _| __|",
    "                         | |) | _|| |__| _|  | | | _| ",
    "                         |___/|___|____|___| |_| |___| eg. \"delete 5\"",
    "                                       +------------------------+",
    "                                       |   OPTIONAL PARAMETERS  |",
    "               +----------+------------+------+------+----------+",
    "               | MODIFIER | TASK INDEX | DATE | TIME | LOCATION |",
    "               +----------+------------+------+------+----------+",
    "               | delete   | <empty>*   | date | time | location |",
    "               | del      | 1          | d    | t    | l        |",
    "               | d        | 12         |      |      |          |",
    "               |          | 1-5        |      |      |          |",
    "               |          | 1 - 5      |      |      |          |",
    "               |          | 1 2 3 4 5  |      |      |          |",
    "               |          |            |      |      |          |",
    "               | clear    | <empty>**  | n/a  | n/a  | n/a      |",
    "               |          | 1          |      |      |          |",
    "               |          | 12         |      |      |          |",
    "               |          | 1-12       |      |      |          |",
    "               |          | 1 - 12     |      |      |          |",
    "               |          |            |      |      |          |",
    "               +----------+------------+------+------+----------+",
    "               *Deleting <empty> index deletes Last Added Task.",
    "               **Typing \"clear\" clears all tasks in view.",
    "",
    "          ============================================================",
    "",
    "                                ___ ___ ___ _____ ",
    "                               | __|   \\_ _|_   _|",
    "                               | _|| |) | |  | |  ",
    "                               |___|___/___| |_|   eg. \"edit 1 sleep 12pm\"",
    "                             +-------------------------------------------+",
    "                             |            ADDITIONAL PARAMETERS          |",
    "     +----------+------------+------------+------------------+-----------+",
    "     | MODIFIER | TASK INDEX | TASK NAME  | DATE & TIME      | LOCATION  |",
    "     +----------+------------+------------+------------------+-----------+",
    "     | edit     | <empty>*   | <new name> | <date>           | @location |",
    "     | change   | 1          |            | <date> to <date> |           |",
    "     | update   | 12         |            | <time>           |           |",
    "     | e, c, u  |            |            | <time> to <time> |           |",
    "     |          |            |            |                  |           |",
    "     +----------+------------+------------+------------------+-----------+",
    "     *Editting <empty> index edits Last Added Task.",
    "     **edits Second Date of Task.",
    "",
    "          ============================================================",
    "",
    "              __  __   _   ___ _  __    _   ___   ___   ___  _  _ ___ ",
    "             |  \\/  | /_\\ | _ \\ |/ /   /_\\ / __| |   \\ / _ \\| \\| | __|",
    "             | |\\/| |/ _ \\|   / ' <   / _ \\\\__ \\ | |) | (_) | .` | _| ",
    "             |_|  |_/_/ \\_\\_|_\\_|\\_\\ /_/ \\_\\___/ |___/ \\___/|_|\\_|___|",
    "",
    "                               eg.\"mark 5 as done\"",
    "                     +----------+------------+-------------+",
    "                     | MODIFIER | TASK INDEX | DONE STATUS |",
    "                     +----------+------------+-------------+",
    "                     | <empty>  | <empty>    | done        |",
    "                     | mark     | 1          | as done     |",
    "                     |          | 12         |             |",
    "                     |          |            | not done    |",
    "                     |          |            | as not done | ",
    "                     |          |            | undone      |",
    "                     +----------+------------+-------------+",
    "                    *<empty> index marks Last Added Task as done/undone.",
    "",
    "          ============================================================",
    "",
    "                           ___ ___   _   ___  ___ _  _ ",
    "                          / __| __| /_\\ | _ \\/ __| || |",
    "                          \\__ \\ _| / _ \\|   / (__| __ |",
    "                          |___/___/_/ \\_\\_|_\\\\___|_||_|",
    "",
    "                              eg. \"search car keys\"",
    "                        +------------+-----------------+",
    "                        | MODIFIER   | SEARCH TERM(S)  |",
    "                        +------------+-----------------+",
    "                        | search     | Waldo           |",
    "                        | search for | Nemo Sea        |",
    "                        | s, f       | Meaning in life |",
    "                        |            |                 |",
    "                        +------------+-----------------+",
    "",
    "          ============================================================",
    "",
    "          <Additional Commands>",
    "",
    "          - UNDO a command",
    "",
    "                \"undo\"",
    "                \"u\"",
    "",
    "          - REDO a command",
    "",
    "                \"redo\"",
    "                \"r\"",
    "",
    "          - Changing SAVE DIRECTORY",
    "",
    "                \"cd D:/Top secret folder\"",
    "                \"cd\"          (Changes to the Default Directory)",
    "",
    "          - Changing VIEW",
    "",
    "                \"v 1\"",
    "                \"viewtype 2\"",
    "                \"viewtype 3\"",
    "",
    "",
    "===============================================================================",
    "",
    "                          PRESS ANY KEY TO CONTINUE...",
    "",
    "===============================================================================",
};

UserInterface::UserInterface(void) {
    system(SYSTEM_COLOUR.c_str());
    COORD windowSize;
    windowSize = GetLargestConsoleWindowSize(GetStdHandle(STD_OUTPUT_HANDLE));

    _maxWindowWidth = windowSize.X;
    _maxWindowLength = windowSize.Y;

    _commandFeedback = CommandFeedback::getInstance();
    _logic = Logic::getInstance();
    _memory = Memory::getInstance();
    _taskList = _memory->ramGetTaskList();
}

UserInterface::~UserInterface(void) {
}

/****************************************************************/

void UserInterface::setEnvironment() {
    setConsoleColorDefault();
    vector<string> welcomeStringVector;

    try {
        _memory->loadSettings();
    } catch(Exception_FileCannotOpen e) {
        welcomeStringVector.push_back(e.getString());
    } catch(Exception_FirstTimeUser e) {
        printProgramWelcomePage();
    }

    try {
        _memory->loadRam();
    } catch(Exception_FileCannotOpen e) {
        welcomeStringVector.push_back(e.getString());
    } catch(Exception_CorruptedFile e) {
        welcomeStringVector.push_back(e.getString());
    }

    if(welcomeStringVector.empty()) {
        welcomeStringVector.push_back(MESSAGE_WELCOME);
    }

    int length,width;
    _memory->getWindowSize(width,length);
    resizeWindow(width,length);

    printNotificationWelcome(welcomeStringVector);
}

void UserInterface::printProgramWelcomePage() {
    size_t size = (sizeof(MESSAGE_WELCOME_SCREEN)/sizeof(*MESSAGE_WELCOME_SCREEN));
    vector<string> welcomeList(MESSAGE_WELCOME_SCREEN, MESSAGE_WELCOME_SCREEN+size);

    resizeWindow(DISPLAY_DEFAULT_WIDTH, DISPLAY_DEFAULT_LENGTH);
    printList(welcomeList);
    _getch();
}

void UserInterface::printNotificationWelcome(vector<string> welcomeStringVector) {
    printDefaultDisplay();
    vector<string>::iterator welcomeStringIter = welcomeStringVector.begin();
    while(welcomeStringIter != welcomeStringVector.end()){
        showToUser(*welcomeStringIter);
        welcomeStringIter++;
    }
}

/****************************************************************/

void UserInterface::printPromptCommand() {
    showToUserMessageBox();
    printCurrentDirectory();
    cout << MESSAGE_COMMAND_PROMPT;
}

void UserInterface::printCurrentDirectory() {
    string saveDirectory = _memory->getSaveDirectory();
    if(saveDirectory.empty()) {
        sprintf_s(buffer, MESSAGE_DIRECTORY_BOX.c_str(), MESSAGE_DEFAULT_DIRECTORY.c_str());
    } else {
        sprintf_s(buffer, MESSAGE_DIRECTORY_BOX.c_str(), (_memory->getSaveDirectory()).c_str());
    }
    showToUser(buffer);
}

string UserInterface::getStringCommand() {
    string command;
    printPromptCommand();
    getline(cin, command);
    return command;
}

void UserInterface::executeCommandUntilExit() {
    string stringCommand;
    Command* command;

    do {
        try {
            stringCommand = getStringCommand();
            LOG(__FILE__,"User enters: \" " + stringCommand + "\"");
            command = _logic->executeCommand(stringCommand);

            printMessageDisplay(command);
            printExecutionMessage(command, VALID_MESSAGE);
        } catch(Exception_InvalidCommand e) {
            command = e.getCommand();
            printMessageDisplay(command);
            printExecutionMessage(command, INVALID_MESSAGE);

        }
    } while(command->getCommandType() != EXIT);      
}

/****************************************************************/

void UserInterface::printMessageDisplay(Command* command) {

    CommandType commandType = command->getCommandType();
    Command* commandRedo;

    switch(commandType) {
    case SEARCH:
        _lastDisplayType = SEARCH_DISPLAY;
        printDisplayType(SEARCH_DISPLAY);
        break;
    case HELP:
        _lastDisplayType = HELP_DISPLAY;
        printDisplayType(HELP_DISPLAY);
        break;
    case EXIT:
        break;
    case INVALID:
        printDisplayType(_lastDisplayType);
        break;
    case REDO:
        commandRedo = command->getRedoneCommand();
        if(commandRedo) {
            printDisplayType(DEFAULT_DISPLAY);
        } else {
            printMessageDisplay(commandRedo);
        }
        break;
    default:
        _lastDisplayType = DEFAULT_DISPLAY;
        printDisplayType(DEFAULT_DISPLAY);
        break;
    }
}

void UserInterface::printDisplayType(DisplayType display) {
    switch(display) {
    case SEARCH_DISPLAY:
        printSearchDisplay();
        break;
    case HELP_DISPLAY:
        printHelpDisplay();
        break;
    default:
        printDefaultDisplay();
        break;
    }
}

void UserInterface::printDefaultDisplay() {
    printTaskList(DATE, _memory->getViewType());
}

void UserInterface::printSearchDisplay() {
    printSearchList(DATE, _memory->getViewType());
}

void UserInterface::printHelpDisplay() {
    printHelpList(DATE, _memory->getViewType());
}

void UserInterface::printExecutionMessage(Command* executionMessage, CommandOutcome commandOutcome) {
    string message;
    try {
        message = _commandFeedback->getCommandFeedback(executionMessage, commandOutcome, _memory->getViewType());
        changeListColour(COLOUR_CATEGORY);
        showToUser(message);
        changeListColour(COLOUR_DEFAULT);
    } catch(Exception_CommandScroll e) {
        system(SYSTEM_COLOUR.c_str());
        changeListColour(COLOUR_SCROLL);
        showToUser(e.getString());
        changeListColour(COLOUR_DEFAULT);
        scrollEngine();
    }
}

/****************************************************************/

void UserInterface::printTaskList(int currentDate, int viewType) {
    ViewType* taskListType;
    vector<string> displayList;
    vector<string> colourCoding;

    switch(viewType) {
    case 1:
        taskListType = new ViewType1(_taskList , currentDate);
        break;
    case 2:
        taskListType = new ViewType2(_taskList , currentDate);
        break;
    case 3:
        taskListType = new ViewType3(_taskList , currentDate);
        break;
    default:
        taskListType = new ViewType0(_taskList , currentDate);
        break;
    }

    displayList = taskListType->createDisplayList();
    colourCoding = taskListType->getColourCoding();

    displayList = createDisplayBox(displayList);
    colourCoding = synchronizeColourCodingWithDisplayBox(colourCoding);

    printViewType(viewType);
    printList(displayList, colourCoding);
    delete taskListType;
}

void UserInterface::printSearchList(int currentDate, int viewType) {
    ViewType* taskListType;
    vector<string> displayList;
    vector<string> colourCoding;

    switch(viewType) {
    case 1:
        taskListType = new ViewType1(_taskList, currentDate);
        break;
    case 2:
        taskListType = new ViewType2(_taskList, currentDate);
        break;
    case 3:
        taskListType = new ViewType3(_taskList, currentDate);
        break;
    default:
        taskListType = new ViewType0(_taskList, currentDate);
        break;
    }
    displayList = taskListType->createSearchList();
    colourCoding = taskListType->getColourCoding();

    displayList = createDisplayBox(displayList);
    colourCoding = synchronizeColourCodingWithDisplayBox(colourCoding);

    printViewType(viewType);
    printList(displayList, colourCoding);

    delete taskListType;
}

void UserInterface::printHelpList(int currentDate, int viewType) {
    size_t size = (sizeof(MESSAGE_HELP_TIPS)/sizeof(*MESSAGE_HELP_TIPS));
    vector<string> helpList(MESSAGE_HELP_TIPS, MESSAGE_HELP_TIPS+size);
    COORD c;

    c.X = DISPLAY_WIDTH;
    c.Y = helpList.size();
    SetConsoleScreenBufferSize(GetStdHandle( STD_OUTPUT_HANDLE), c);

    changeListColour(COLOUR_HELP);
    printList(helpList);

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
    DISPLAY_LENGTH = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
	_bufferBottomLimit = csbi.srWindow.Bottom;
    scrollByAbsoluteCoord(size - DISPLAY_LENGTH);
    keyboardCommandScroll();

    changeListColour(COLOUR_DEFAULT);
    printTaskList(currentDate, viewType);
    _lastDisplayType = DEFAULT_DISPLAY;
}

void UserInterface::printViewType(int viewType) {
    showToUserMessageBox();
    changeListColour(COLOUR_VIEW_INDICATOR);
    switch(viewType) {
    case 1:
        showToUser(MESSAGE_VIEWTYPE_1);
        break;
    case 2:
        showToUser(MESSAGE_VIEWTYPE_2);
        break;
    case 3:
        showToUser(MESSAGE_VIEWTYPE_3);
        break;
    default:
        showToUser(MESSAGE_VIEWTYPE_0);
        break;
    }
    changeListColour(COLOUR_DEFAULT);
}

/****************************************************************/

void UserInterface::printList(vector<string> displayList) {
    vector<string>::iterator displayListIter = displayList.begin();

    while(displayListIter != displayList.end()) {
        showToUser(*displayListIter);
        displayListIter++;
    }
}

void UserInterface::printList(vector<string> displayList, vector<string> colourCoding) {
    vector<string>::iterator displayListIter = displayList.begin();
    vector<string>::iterator colourCodingIter = colourCoding.begin();

    while(displayListIter != displayList.end()) {
        changeListColour(*colourCodingIter);
        showToUser(*displayListIter);
        displayListIter++;
        if(colourCodingIter != colourCoding.end()-1) {
            colourCodingIter++;
        }
    }
}

/****************************************************************/

vector<string> UserInterface::createDisplayBox(vector<string> displayList) {
    vector<string>::iterator displayListIter;
    string messageBox;
    COORD c;

    setDisplayBoxLength(displayList.size());

    messageBox.assign(DISPLAY_WIDTH, MESSAGE_BOX_CHARACTER);
    messageBox.pop_back();

    displayList.insert(displayList.begin(), messageBox);
    //displayList.insert(displayList.begin(), MESSAGE_VOID_STRING);
    displayListIter = displayList.begin();
    displayListIter++;

    while(displayList.size() < DISPLAY_BOX_LENGTH) {
        displayList.push_back(MESSAGE_VOID_STRING);
    }
    displayList.insert(displayList.end(), messageBox);

    c.X = DISPLAY_WIDTH;
    c.Y = displayList.size() + DISPLAY_SYNC_LENGTH - 1;
	_bufferBottomLimit = c.Y;
    SetConsoleScreenBufferSize(GetStdHandle( STD_OUTPUT_HANDLE), c);

    return displayList;
}

void UserInterface::showToUser(string message) {
    cout << message << endl;
}

void UserInterface::showToUserMessageBox() {
    string messageBox;
    messageBox.assign(DISPLAY_WIDTH, MESSAGE_BOX_CHARACTER);
    messageBox.pop_back();

    showToUser(messageBox);
}

/****************************************************************/

void UserInterface::setDisplayBoxLength(int size) {
    //current window size
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
    DISPLAY_WIDTH = csbi.srWindow.Right - csbi.srWindow.Left + 1;
    DISPLAY_LENGTH = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;

    //get appropriate minimum window size
    DISPLAY_WIDTH = getLargerValue(DISPLAY_WIDTH, DISPLAY_DEFAULT_WIDTH);
    DISPLAY_LENGTH = getLargerValue(DISPLAY_LENGTH, DISPLAY_DEFAULT_LENGTH);
    //DISPLAY_LENGTH = getLargerValue(DISPLAY_LENGTH, size + DISPLAY_SYNC_LENGTH + 1);

    DISPLAY_BOX_WIDTH = DISPLAY_WIDTH - DISPLAY_SYNC_WIDTH;
    DISPLAY_BOX_LENGTH = DISPLAY_LENGTH - DISPLAY_SYNC_LENGTH;

    resizeWindow(DISPLAY_WIDTH, DISPLAY_LENGTH);
    _memory->changeWindowSize(DISPLAY_WIDTH, DISPLAY_LENGTH);
}

void UserInterface::resizeWindow(int width, int length) {
    sprintf_s(buffer, SYSTEM_MODE_CON.c_str(), width, length);
    system(buffer);
}

int UserInterface::getLargerValue(int value1, int value2) {
    if(value1 < value2) {
        return value2;
    } else {
        return value1;
    }

}

/****************************************************************/

vector<string> UserInterface::synchronizeColourCodingWithDisplayBox(vector<string> colourCoding) {
    int i = 0;
    while(i < 1) {
        colourCoding.insert(colourCoding.begin(),COLOUR_DEFAULT);
        i++;
    }
    colourCoding.insert(colourCoding.end(),COLOUR_DEFAULT);
    return colourCoding;
}

void UserInterface::changeListColour(string colourCoding) {
    if(colourCoding == COLOUR_DEFAULT) {
        setConsoleColorDefault();
        return;
    }
    if(colourCoding == COLOUR_NEW) {
        setConsoleColor(BLACK, LIGHT_RED);
        return;
    } 
    if(colourCoding == COLOUR_DONE) {
        setConsoleColor(BLACK, GREY);
        return;
    } 
    if(colourCoding == COLOUR_SEARCH) {
        setConsoleColor(BLACK, LIGHT_AQUA);
        return;
    } 
    if(colourCoding == COLOUR_HELP) {
        setConsoleColor(BLACK, LIGHT_YELLOW);
        return;
    } 
    if(colourCoding == COLOUR_CATEGORY) {
        setConsoleColor(BLACK, LIGHT_AQUA);
        return;
    } 
    if(colourCoding == COLOUR_FEEDBACK) {
        setConsoleColor(BLACK, LIGHT_AQUA);
        return;
    } 
    if(colourCoding == COLOUR_VIEW_INDICATOR) {
        setConsoleColor(BLACK, LIGHT_GREEN);
        return;
    }
    if(colourCoding == COLOUR_SCROLL) {
        setConsoleColor(BLACK, LIGHT_RED);
        return;
    }

}

void UserInterface::setConsoleColor(int background, int foreground) {
    HANDLE  hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    int colour = background * 16 + foreground;
    SetConsoleTextAttribute(hConsole, colour);
}

void UserInterface::setConsoleColorDefault() {
    setConsoleColor(BLACK, LIGHT_WHITE);
}

/****************************************************************/

void UserInterface::scrollEngine() {
    showToUserMessageBox();
    cout << MESSAGE_SCROLL_PROMPT;
    keyboardCommandScroll();

    printDefaultDisplay();
    showToUser(MESSAGE_SCROLL_EXIT);
}

void UserInterface::keyboardCommandScroll() {
    int keyPress;
    do {
        keyPress = _getch();
        switch(keyPress) {
        case 72:
            scrollByAbsoluteCoord(1);
            break;
        case 80:
            scrollByAbsoluteCoord(-1);
            break;
        case 73:
            scrollByAbsoluteCoord(1);
            scrollByAbsoluteCoord(1);
            scrollByAbsoluteCoord(1);
            scrollByAbsoluteCoord(1);
            scrollByAbsoluteCoord(1);
            scrollByAbsoluteCoord(1);
            break;
        case 81:
            scrollByAbsoluteCoord(-1);
            scrollByAbsoluteCoord(-1);
            scrollByAbsoluteCoord(-1);
            scrollByAbsoluteCoord(-1);
            scrollByAbsoluteCoord(-1);
            scrollByAbsoluteCoord(-1);
            break;
        }
    } while(notExitKey(keyPress));

}

void UserInterface::scrollByAbsoluteCoord(int iRows) {
    HANDLE hStdout;
    CONSOLE_SCREEN_BUFFER_INFO csbiInfo; 
    SMALL_RECT srctWindow; 

    hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(hStdout, &csbiInfo);
    srctWindow = csbiInfo.srWindow; 

    if (srctWindow.Bottom >= _bufferBottomLimit && iRows == -1) {
        return;
    } 

    if ( srctWindow.Top >= iRows ) { 
        srctWindow.Top -= (SHORT)iRows;
        srctWindow.Bottom -= (SHORT)iRows;
    }

    SetConsoleWindowInfo(hStdout, TRUE, &srctWindow);
}

bool UserInterface::notExitKey(int keyPress) {
    if(keyPress == 224
        || keyPress == 72
        || keyPress == 224
        || keyPress == 80
        || keyPress == 224
        || keyPress == 75
        || keyPress == 224
        || keyPress == 77
        || keyPress == 224
        || keyPress == 73
        || keyPress == 224
        || keyPress == 81
        || keyPress == 224
        || keyPress == 71
        || keyPress == 224
        || keyPress == 79
        || keyPress == 224
        || keyPress == 82
        || keyPress == 224
        || keyPress == 83) {
            return true;
    }	
    return false;
}

/*************************Unused*********************************/
/****************************************************************/

void UserInterface::printPromptHelp() {
    size_t size = (sizeof(MESSAGE_HELP_TIPS)/sizeof(*MESSAGE_HELP_TIPS));
    vector<string> helpList(MESSAGE_HELP_TIPS,MESSAGE_HELP_TIPS+size);
    vector<string>::iterator helpListIter = helpList.begin();

    while(helpListIter!= helpList.end()) {
        showToUser(*helpListIter);
        helpListIter++;
    }
}


```
###### doMe\UserInterface.h
``` h
#pragma once
#include <string>
#include <fstream>
#include <iostream>
#include <sstream>
#include <vector>
#include <list>
#include <windows.h>
#include <conio.h>
#include <ctime>
#include <assert.h>

#include "Logic.h"
#include "Memory.h"
#include "CommandFeedback.h"
#include "Command.h"
#include "Task.h"
#include "ViewType.h"
#include "ViewType0.h"
#include "ViewType1.h"
#include "ViewType2.h"
#include "ViewType3.h"

using namespace std;

class UserInterface {

public:
	//UserInterface(void);
	UserInterface();
	~UserInterface(void);

	void setEnvironment();
	void executeCommandUntilExit();

#ifndef TESTMODE 
private: 
#else 
public: 
#endif
	enum DisplayType {
		DEFAULT_DISPLAY, SEARCH_DISPLAY, HELP_DISPLAY
	};
	DisplayType _lastDisplayType;
	Logic* _logic;
	Memory* _memory;
	CommandFeedback* _commandFeedback;
	list<Task*>* _taskList;
	int _bufferBottomLimit;

	int _maxWindowWidth;
	int _maxWindowLength;
	char buffer[255];

	//Initial programme page
	void printProgramWelcomePage();
	void printNotificationWelcome(vector<string> welcomeStringVector);

	//prompts
	void printPromptCommand();
	void printCurrentDirectory();
	void printPromptHelp();

	//Message display
	void printMessageDisplay(Command* command);
	void printDisplayType(DisplayType display);
	void printDefaultDisplay();
	void printSearchDisplay();
	void printHelpDisplay();

	void printTaskList(int currentDate ,int viewType);
	void printSearchList(int currentDate, int viewType);
	void printHelpList(int currentDate, int viewType);
	void printViewType(int viewType);

	//notification
	void printExecutionMessage(Command* executionMessage, CommandOutcome commandOutcome);

	//helper
	void showToUser(string message);
	void showToUserMessageBox();
	string getStringCommand();
	vector<string> createDisplayBox(vector<string> displayList);
	vector<string> synchronizeColourCodingWithDisplayBox(vector<string> colourCoding);
	void printList(vector<string> displayList); 
	void printList(vector<string> displayList, vector<string> colourCoding);

	//window size related function
	void setDisplayBoxLength(int size);
	int getLargerValue(int value1, int value2);
	void resizeWindow(int width, int length);

	static unsigned int DISPLAY_WIDTH;
	static unsigned int DISPLAY_LENGTH;
	static unsigned int DISPLAY_BOX_WIDTH;
	static unsigned int DISPLAY_BOX_LENGTH;
	static const int DISPLAY_DEFAULT_WIDTH;
	static const int DISPLAY_DEFAULT_LENGTH;
	static const int DISPLAY_SYNC_WIDTH;
	static const int DISPLAY_SYNC_LENGTH;

	//window text colour
	enum Colour {
		BLACK, BLUE, GREEN, AQUA, RED, PURPLE, YELLOW, WHITE, GREY, LIGHT_BLUE, LIGHT_GREEN, LIGHT_AQUA, LIGHT_RED, LIGHT_PURPLE, LIGHT_YELLOW, LIGHT_WHITE
	};

	static const string COLOUR_DEFAULT;
	static const string COLOUR_NEW;
	static const string COLOUR_DONE;
	static const string COLOUR_SEARCH;
	static const string COLOUR_HELP;
	static const string COLOUR_CATEGORY;
	static const string COLOUR_FEEDBACK;
	static const string COLOUR_VIEW_INDICATOR;
	static const string COLOUR_SCROLL;

	void changeListColour(string colourCoding);
	void setConsoleColor(int background, int foreground);
	void setConsoleColorDefault();

	//help scroll
	void scrollEngine(); 
	void keyboardCommandScroll();
	void scrollByAbsoluteCoord(int iRows);
	bool notExitKey(int keyPress);

	//Text Strings
	static const string SYSTEM_MODE_CON;
	static const string SYSTEM_COLOUR;
	static const string MESSAGE_WELCOME;
	static const char MESSAGE_BOX_CHARACTER;
	static const string MESSAGE_VOID_STRING; 

	static const string MESSAGE_VIEWTYPE_0;
	static const string MESSAGE_VIEWTYPE_1;
	static const string MESSAGE_VIEWTYPE_2;
	static const string MESSAGE_VIEWTYPE_3;

	static const string MESSAGE_COMMAND_PROMPT;
	static const string MESSAGE_SCROLL_PROMPT;
	static const string MESSAGE_SCROLL_EXIT;
	static const string MESSAGE_DEFAULT_DIRECTORY;
	static const string MESSAGE_DIRECTORY_BOX;
	static const string MESSAGE_WELCOME_SCREEN[];
	static const string MESSAGE_HELP_TIPS[];
};

```
###### doMe\ViewType.cpp
``` cpp
#include "ViewType.h"

const int ViewType::END_OF_WEEK = 6;
const int ViewType::NO_OF_DAYS_IN_WEEK = 7;
const int ViewType::TIME_STRING_INT = 4;//Meridiem size (am/pm) + 2
const int ViewType::TIME_MIDDAY = 1200;
const string ViewType::MESSAGE_TODAY = "Today";
const string ViewType::MESSAGE_DISPLAY_CONTENTS = "%d. %s";
const string ViewType::MESSAGE_DATE_SEPERATOR = "/";
const string ViewType::MESSAGE_TIME_SEPERATOR = ":";
const string ViewType::MESSAGE_TIMING_SEPERATOR = "- ";
const string ViewType::MESSAGE_MONTH_SEPERATOR = "-";
const string ViewType::MESSAGE_NEXT = "Next ";
const string ViewType::MESSAGE_AM = "am";
const string ViewType::MESSAGE_PM = "pm";
const string ViewType::MESSAGE_VOID_STRING = "";
const string ViewType::MESSAGE_SPACE_STRING = " ";
const string ViewType::MESSAGE_BRACKETS = "(%s)";
const string ViewType::MESSAGE_FLOATING_TASK = "<No deadline>";
const string ViewType::COLOUR_DEFAULT = "DEFAULT";
const string ViewType::COLOUR_NEW = "NEW";
const string ViewType::COLOUR_DONE = "DONE";
const string ViewType::COLOUR_CATEGORY = "CATEGORY";
const string ViewType::COLOUR_SEARCH = "SEARCH";
const string ViewType::MESSAGE_EMPTY_LIST[] = {
    "                               <list is empty!>",
    "                 Type \"HELP\" to see list of available commands."
};
const string ViewType::MESSAGE_MONTH[] = { 
    "Jan", 
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
}; 

ViewType::ViewType(void) {
}

ViewType::ViewType(list<Task*> *taskList, int currentDate) {
    Commons commons;
    _taskList = taskList;
    _currentDate = currentDate;

    _dayToEndOfWeek  = END_OF_WEEK - commons.getDayNumber(_currentDate);
}

ViewType::~ViewType(void) {
}

/****************************************************************/

vector<string> ViewType::createDisplayList() {
    if((*_taskList).empty()) {
        size_t size = (sizeof(MESSAGE_EMPTY_LIST)/sizeof(*MESSAGE_EMPTY_LIST));
        vector<string> emptyList(MESSAGE_EMPTY_LIST,MESSAGE_EMPTY_LIST+size);
        _displayList = emptyList;
    } else {
        list<Task*>::iterator taskListIter = ((*_taskList).begin());
        Memory* memory;
        int index = 1;
        unsigned int i = 0;

        memory = Memory::getInstance();
        Task* recentTask = memory->ramGetLastModifiedTask();

        vector<string> categoryHeader = getCategoryHeader();

        if(!categoryHeader.empty()) {
            _displayList.push_back(categoryHeader[i]);
            _colourCoding.push_back(COLOUR_CATEGORY);
            i++;
        }
        while(taskListIter != (*_taskList).end()) {
            while((isInNextCategory(*taskListIter, i)) && (i < categoryHeader.size())) {
                _displayList.push_back("");
                _colourCoding.push_back(COLOUR_DEFAULT);

                _displayList.push_back(categoryHeader[i]);
                _colourCoding.push_back(COLOUR_CATEGORY);
                i++;
            }

            _displayList.push_back(createTaskString(*taskListIter,index));
            _colourCoding.push_back(colourCoderTag(*taskListIter, recentTask));
            index++;
            taskListIter++;
        }
    }
    return _displayList;
}

//search list without category
vector<string> ViewType::createSearchList() {
    if((*_taskList).empty()) {
        size_t size = (sizeof(MESSAGE_EMPTY_LIST)/sizeof(*MESSAGE_EMPTY_LIST));
        vector<string> emptyList(MESSAGE_EMPTY_LIST,MESSAGE_EMPTY_LIST+size);
        _displayList = emptyList;
        _colourCoding.push_back(COLOUR_SEARCH);
    } else {
        list<Task*>::iterator taskListIter = (*_taskList).begin();
        int index = 1;

        while(taskListIter != (*_taskList).end()) {
            _displayList.push_back(ViewType::createTaskString(*taskListIter,index));
            _colourCoding.push_back(COLOUR_SEARCH);
            index++;
            taskListIter++;
        }
    }
    return _displayList;
}

//create task string with index
string ViewType::createTaskString(Task* individualTask, int index) {
    string taskString;
    taskString = getTaskString(individualTask);

    sprintf_s(buffer, MESSAGE_DISPLAY_CONTENTS.c_str(),index, taskString.c_str());

    return buffer;
}

string ViewType::getTaskString(Task* individualTask) {
    string name = individualTask->getName();
    string location = individualTask->getLocation();
    string date1 = getDateTaskString(individualTask->getDate1());
    string date2 = getDateTaskString(individualTask->getDate2());
    string time1 = getTimeTaskString(individualTask->getTime1());
    string time2 = getTimeTaskString(individualTask->getTime2());

    string taskString = formatTaskString(name,date1,date2,time1,time2,location);

    return taskString;
}

string ViewType::colourCoderTag(Task* individualTask, Task* recentTask) {
    if(individualTask->getDoneStatus() == 1) {
        return COLOUR_DONE;
    } else {
        if(recentTask == individualTask) {
            return COLOUR_NEW;
        } 
        return COLOUR_DEFAULT;
    }
}

vector<string> ViewType::getColourCoding() {
    return _colourCoding;
}

/****************************************************************/

string ViewType::formatTaskString(string name , string date1 , string date2 , string time1 , string time2 , string location) {
    string taskString;
    string dateString;

    name = formateAddSpace(name);
    date1 = formateAddSpace(date1);
    date2 = formateAddSpace(date2);
    time1 = formateAddSpace(time1);
    time2 = formateAddSpace(time2);

    location = formateAddBracket(location);
    location = formateAddSpace(location);

    dateString = formateDateString(time1 + date1 , time2 + date2);
    taskString = name + location + dateString;

    //taskString.pop_back();
    return taskString;
}

string ViewType::formateAddSpace(string s) {
    if(!s.empty()) {
        return s + MESSAGE_SPACE_STRING;
    } 
    return s;
}

string ViewType::formateAddBracket(string s) {
    if(!s.empty()) {
        sprintf_s(buffer, MESSAGE_BRACKETS.c_str(), s.c_str());
        return buffer;
    }
    return s;
}

string ViewType::formateDateString(string s1, string s2) {
    string time;
    if((s1.empty()) && (s2.empty())) {
        return MESSAGE_FLOATING_TASK;
    }
    if((s1.empty()) || (s2.empty())) {
        time = s1 + s2;
        time.pop_back();
        sprintf_s(buffer, MESSAGE_BRACKETS.c_str(),time.c_str());
        return buffer;
    } else {
        time = s1 + MESSAGE_TIMING_SEPERATOR + s2;
        time.pop_back();
        sprintf_s(buffer, MESSAGE_BRACKETS.c_str(),time.c_str());
        return buffer;

    }
}

/****************************************************************/

string ViewType::integerToString(int integer) {
    ostringstream oss;
    oss << integer;  
    return oss.str();
}

string ViewType::timeToString(string time) {
    string timeString = time;
    if(time.size() < 3) {
        timeString.insert(0,"0");
    }
    if(time.size()  < 2) {
        timeString.insert(0,"0");
    }
    return timeString;
}

/****************************************************************/
/*Overriding functions*/
/****************************************************************/

vector<string> ViewType::getCategoryHeader() {
    vector<string> null;
    return null;
}

bool ViewType::isInNextCategory(Task* individualTask, int i) {
    return true;
}

string ViewType::getDateTaskString(int date) {
    string dateString;
    string day;
    string month;
    string year;
    int weekRange;
    Commons commons;

    int test = _dayToEndOfWeek;
    weekRange = commons.addToDate(_dayToEndOfWeek, _currentDate);

    if(_currentDate <= date && date <= weekRange && date > 0) {
        if(_currentDate == date) {
            return MESSAGE_TODAY;
        } else {
            return commons.getDateStringDay(commons.getDayNumber(date));
        }
    } else {
        if(date > 0) {
            if(weekRange < date && date <= weekRange + NO_OF_DAYS_IN_WEEK) {
                return MESSAGE_NEXT + commons.getDateStringDay(commons.getDayNumber(date));
            } else {
                day = getDay(date);
                month = getMonth(date);
                dateString = day + MESSAGE_MONTH_SEPERATOR + month;

                return dateString;
            }
        } else {
            return MESSAGE_VOID_STRING;
        }
    }
}

string ViewType::getTimeTaskString(int time) {
    string timeString;

    if(time >= 0) {
        if(time > TIME_MIDDAY) {
            time = time - TIME_MIDDAY;
            timeString = integerToString(time);
            timeString = timeString + MESSAGE_PM;
        } else {
            if(time < 100) {
                time = time + TIME_MIDDAY;
            } 

            timeString = integerToString(time);
            timeString = timeString + MESSAGE_AM;
        }
        timeString.insert(timeString.size() - TIME_STRING_INT, MESSAGE_TIME_SEPERATOR);
        return timeString;

    } else {
        return MESSAGE_VOID_STRING;
    }
}

string ViewType::getDay(int date) {
    ostringstream oss;
    oss << date % 100;
    return oss.str();
}

string ViewType::getMonth(int date) {
    int month;
    date = date / 100;
    month = date % 100;
    assert((month <= 12) && (month > 0));

    return MESSAGE_MONTH[month-1];
}

string ViewType::getYear(int date) {
    ostringstream oss;
    oss << date / 10000;
    return oss.str();
}

```
###### doMe\ViewType.h
``` h
#pragma once
#include <string>
#include <sstream>
#include <vector>
#include <iostream>
#include <list>
#include <assert.h>

#include "Commons.h"
#include "Task.h"
#include "Memory.h"

using namespace std;

class ViewType {

#ifndef TESTMODE 
protected: 
#else 
public: 
#endif
    list<Task*> *_taskList;
    vector<string> _colourCoding;
    vector<string> _displayList;
    int _currentDate;
    int _dayToEndOfWeek;
    char buffer[255];

    //overiding functions
    virtual vector<string> getCategoryHeader();
    virtual bool isInNextCategory(Task* individualTask, int i);
    virtual string getTimeTaskString(int time);
    virtual string getDateTaskString(int date);
    virtual string getDay(int date);
    virtual string getMonth(int date);
    virtual string getYear(int date);

    string formatTaskString(string name , string date1 , string date2 , string time1 , string time2 , string location);
    string formateDateString(string s1, string s2);
    string formateAddSpace(string s);
    string formateAddBracket(string s);

    string createTaskString(Task* individualTask, int index);
    string colourCoderTag(Task* individualTask, Task* recentTask);

    string integerToString(int integer);
    string timeToString(string time);

    static const int END_OF_WEEK;
    static const int NO_OF_DAYS_IN_WEEK;
    static const int TIME_STRING_INT;
    static const int TIME_MIDDAY;
    static const string MESSAGE_TODAY;
    static const string MESSAGE_DISPLAY_CONTENTS;
    static const string MESSAGE_DATE_SEPERATOR;
    static const string MESSAGE_TIME_SEPERATOR;
    static const string MESSAGE_TIMING_SEPERATOR;
    static const string MESSAGE_MONTH_SEPERATOR;
    static const string MESSAGE_VOID_STRING;
    static const string MESSAGE_SPACE_STRING;
    static const string MESSAGE_BRACKETS;
    static const string MESSAGE_FLOATING_TASK;
    static const string MESSAGE_DISPLAY_HEADER;
    static const string MESSAGE_NEW_LINE;
    static const string MESSAGE_EMPTY_LIST[];
    static const string MESSAGE_MONTH[];
    static const string MESSAGE_NEXT;
    static const string MESSAGE_AM;
    static const string MESSAGE_PM;
    static const string COLOUR_DEFAULT;
    static const string COLOUR_NEW;
    static const string COLOUR_DONE;
    static const string COLOUR_CATEGORY;
    static const string COLOUR_SEARCH;

public:
    ViewType(void);
    ViewType(list<Task*> *taskList, int currentDate);
    ~ViewType(void);

    vector<string> createDisplayList();
    vector<string> createSearchList();
    string getTaskString(Task* individualTask);
    vector<string> getColourCoding();
};

```
###### doMe\ViewType1.cpp
``` cpp
#include "ViewType1.h"

const string ViewType1::MESSAGE_DISPLAY_HEADER[] = {
    "<No Deadlines>",
    "<Past>",
    "<TODAY>",
    "<This Week>",
    "<Next Week>",
    "<Future>",
    "<Done>"
};

ViewType1::ViewType1(void) {
}

ViewType1::ViewType1(list<Task*> *taskList, int currentDate) : ViewType(taskList,currentDate) {
}

ViewType1::~ViewType1(void) {
}

/****************************************************************/

vector<string> ViewType1::getCategoryHeader() {
    size_t size = (sizeof(MESSAGE_DISPLAY_HEADER)/sizeof(*MESSAGE_DISPLAY_HEADER));
    vector<string> categoryHeader(MESSAGE_DISPLAY_HEADER, MESSAGE_DISPLAY_HEADER+size);

    return categoryHeader;
}

bool ViewType1::isInNextCategory(Task* individualTask, int i) {
    int date; 
    int date1 = individualTask->getDate1();
    int date2 = individualTask->getDate2();
    Commons commons;
    if(date1 != -1) {
        date = date1;
    } else {
        date = date2;
    }

    switch(i) {
    case 0:
        return true;
        break; 
    case 1:
        if(date >= 0) {
            return true;
            break;
        } else {
            return false;
            break;
        }
    case 2:
        if(date >= _currentDate) {
            return true;
            break;
        } else {
            return false;
            break;
        }
    case 3:
        if(date > _currentDate) {
            return true;
            break;
        } else {
            return false;
            break;
        }
    case 4:
        if(date > commons.addToDate(_dayToEndOfWeek,_currentDate) ) {
            return true;
            break;
        } else {
            return false;
            break;
        }
    case 5:
        if(date > commons.addToDate(_dayToEndOfWeek + NO_OF_DAYS_IN_WEEK,_currentDate) ) {
            return true;
            break;
        } else {
            return false;
            break;
        }
    case 6:
        if(individualTask->getDoneStatus() == true) {
            return true;
            break;
        } else {
            return false;
            break;
        }
    default:
        return false;
        break;
    }
    return false;
    /*
    switch(i) {
    case 0:
    return true;
    break; 
    case 1:
    if(individualTask->getDoneStatus() == false) {
    return true;
    break;
    } else {
    return false;
    break;
    }
    case 2:
    if(date >= 0) {
    return true;
    break;
    } else {
    return false;
    break;
    }
    case 3:
    if(date >= _currentDate) {
    return true;
    break;
    } else {
    return false;
    break;
    }
    case 4:
    if(date > _currentDate) {
    return true;
    break;
    } else {
    return false;
    break;
    }
    case 5:
    if(date > commons.addToDate(_dayToEndOfWeek,_currentDate) ) {
    return true;
    break;
    } else {
    return false;
    break;
    }
    case 6:
    if(date > commons.addToDate(_dayToEndOfWeek + NO_OF_DAYS_IN_WEEK,_currentDate) ) {
    return true;
    break;
    } else {
    return false;
    break;
    }
    default:
    return false;
    break;
    }
    return false;
    */
}

/****************************************************************/


```
###### doMe\ViewType1.h
``` h
#pragma once
#include "ViewType.h"

class ViewType1 : public ViewType {
private:
    static const string MESSAGE_DISPLAY_HEADER[];

    //overiding functions
    bool isInNextCategory(Task* individualTask, int i);
    vector<string> getCategoryHeader();

public:
    ViewType1(void);
    ViewType1(list<Task*> *taskList, int currentDate);
    ~ViewType1(void);
};

```
###### doMe\ViewType2.cpp
``` cpp
#include "ViewType2.h"

const string ViewType2::MESSAGE_DISPLAY_HEADER[] = {
    "<No Deadlines, Past>",
    "<TODAY>",
    "<This Week>",
    "<Next Week>",
    "<Future>",
    "<Done>"
};

ViewType2::ViewType2(void) {
}

ViewType2::ViewType2(list<Task*> *taskList, int currentDate) : ViewType(taskList,currentDate) {
}

ViewType2::~ViewType2(void) {
}

/****************************************************************/

vector<string> ViewType2::getCategoryHeader() {
    size_t size = (sizeof(MESSAGE_DISPLAY_HEADER)/sizeof(*MESSAGE_DISPLAY_HEADER));
    vector<string> categoryHeader(MESSAGE_DISPLAY_HEADER, MESSAGE_DISPLAY_HEADER+size);

    return categoryHeader;
}

bool ViewType2::isInNextCategory(Task* individualTask, int i) {
    int date; 
    int date1 = individualTask->getDate1();
    int date2 = individualTask->getDate2();
    Commons commons;
    if(date1 != -1) {
        date = date1;
    } else {
        date = date2;
    }

    switch(i) {
    case 0:
        return true;
        break; 
    case 1:
        if(individualTask->getDoneStatus() == false && date >= _currentDate) {
            return true;
            break;
        } else {
            return false;
            break;
        }
    case 2:
        if(date > _currentDate) {
            return true;
            break;
        } else {
            return false;
            break;
        }
    case 3:
        if(date > commons.addToDate(_dayToEndOfWeek,_currentDate) ) {
            return true;
            break;
        } else {
            return false;
            break;
        }
    case 4:
        if(date > commons.addToDate(_dayToEndOfWeek + NO_OF_DAYS_IN_WEEK,_currentDate) ) {
            return true;
            break;
        } else {
            return false;
            break;
        }
    case 5:
        if(individualTask->getDoneStatus() == true) {
            return true;
            break;
        } else {
            return false;
            break;
        }
    default:
        return false;
        break;
    }
    return false;
}

/****************************************************************/


```
###### doMe\ViewType2.h
``` h
#pragma once
#include "ViewType.h"

class ViewType2 : public ViewType {
private:
    static const string MESSAGE_DISPLAY_HEADER[];

    //overiding functions
    bool isInNextCategory(Task* individualTask, int i);
    vector<string> getCategoryHeader();
   
public:
    ViewType2(void);
    ViewType2(list<Task*> *taskList, int currentDate);
    ~ViewType2(void);
};

```
###### doMe\ViewType3.cpp
``` cpp
#include "ViewType3.h"

const string ViewType3::MESSAGE_DISPLAY_HEADER[] = {
    "<No Deadlines, Past>",
    "<TODAY>",
    "<Future>",
    "<Done>"
};

ViewType3::ViewType3(void) {
}

ViewType3::ViewType3(list<Task*> *taskList, int currentDate) : ViewType(taskList,currentDate) {
}

ViewType3::~ViewType3(void) {
}

/****************************************************************/

vector<string> ViewType3::getCategoryHeader() {
    size_t size = (sizeof(MESSAGE_DISPLAY_HEADER)/sizeof(*MESSAGE_DISPLAY_HEADER));
    vector<string> categoryHeader(MESSAGE_DISPLAY_HEADER, MESSAGE_DISPLAY_HEADER+size);

    return categoryHeader;
}

bool ViewType3::isInNextCategory(Task* individualTask, int i) {
    int date; 
    int date1 = individualTask->getDate1();
    int date2 = individualTask->getDate2();
    Commons commons;
    if(date1 != -1) {
        date = date1;
    } else {
        date = date2;
    }

    switch(i) {
    case 0:
        return true;
        break; 
    case 1:
        if(individualTask->getDoneStatus() == false && date >= _currentDate) {
            return true;
            break;
        } else {
            return false;
            break;
        }
    case 2:
        if(date > _currentDate) {
            return true;
            break;
        } else {
            return false;
            break;
        }
    case 3:
        if(individualTask->getDoneStatus() == true) {
            return true;
            break;
        } else {
            return false;
            break;
        }
    default:
        return false;
        break;
    }
    return false;
}

/****************************************************************/
```
###### doMe\ViewType3.h
``` h
#pragma once
#include "ViewType.h"

class ViewType3 : public ViewType {
private:
    //overwriting funciton
    bool isInNextCategory(Task* individualTask, int i);
    vector<string> getCategoryHeader();

    static const string MESSAGE_DISPLAY_HEADER[];
    
public:
    ViewType3(void);
    ViewType3(list<Task*> *taskList, int currentDate);
    ~ViewType3(void);
};

```
###### doMeTests_Command\TesterHeader.h
``` h
#ifndef TESTMODE 

#else
#pragma once
#include "Exception_CorruptedFile.cpp"
#include "Exception_ExceededParameterLimit.cpp"
#include "Exception_FileCannotOpen.cpp"
#include "Exception_FirstTimeUser.cpp"
#include "Exception_InvalidCommand.cpp"
#include "Exception_CommandScroll.cpp"

#include "Logic.cpp"
#include "Commons.cpp"
#include "Task.cpp"
#include "Command.cpp"
#include "Command_Add.cpp"
#include "Command_Clear.cpp"
#include "Command_Edit.cpp"
#include "Command_Exit.cpp"
#include "Command_Help.cpp"
#include "Command_Invalid.cpp"
#include "Command_Redo.cpp"
#include "Command_Scroll.cpp"
#include "Command_SaveDirectory.cpp"
#include "Command_Search.cpp"
#include "Command_Undo.cpp"
#include "Command_ViewType.cpp"

#include "Memory.h"
#include "Memory.cpp"
#include "Settings.h"
#include "Settings.cpp"
#include "RAM.h"
#include "RAM.cpp"
#include "Storage.h"
#include "Storage.cpp"

#include "UserInterface.cpp"
#include "CommandFeedback.cpp"
#include "ViewType.cpp"
#include "ViewType0.cpp"
#include "ViewType1.cpp"
#include "ViewType2.cpp"
#include "ViewType3.cpp"

#include "SynonymList.h"
#include "SynonymList.cpp"
#include "Dictionary.h"
#include "Dictionary.cpp"
#include "InputTokens.h"
#include "InputTokens.cpp"
#include "ChronoInterpreter.h"
#include "ChronoInterpreter.cpp"
#include "TaskPacker.h"
#include "TaskPacker.cpp"
#include "CommandPacker.h"
#include "CommandPacker.cpp"
#include "Parser_Interface.h"
#include "Parser_Interface.cpp"
#include "Parser.h"
#include "Parser.cpp"

#endif
```
###### IntegrationTest\TesterHeader.h
``` h
#ifndef TESTMODE 

#else
#pragma once
#include "Exception_CorruptedFile.cpp"
#include "Exception_ExceededParameterLimit.cpp"
#include "Exception_FileCannotOpen.cpp"
#include "Exception_FirstTimeUser.cpp"
#include "Exception_InvalidCommand.cpp"
#include "Exception_CommandScroll.cpp"

#include "Logic.cpp"
#include "Commons.cpp"
#include "Task.cpp"
#include "Command.cpp"
#include "Command_Add.cpp"
#include "Command_Clear.cpp"
#include "Command_Edit.cpp"
#include "Command_Exit.cpp"
#include "Command_Help.cpp"
#include "Command_Invalid.cpp"
#include "Command_Redo.cpp"
#include "Command_Scroll.cpp"
#include "Command_SaveDirectory.cpp"
#include "Command_Search.cpp"
#include "Command_Undo.cpp"
#include "Command_ViewType.cpp"

#include "Memory.h"
#include "Memory.cpp"
#include "Settings.h"
#include "Settings.cpp"
#include "RAM.h"
#include "RAM.cpp"
#include "Storage.h"
#include "Storage.cpp"

#include "UserInterface.cpp"
#include "CommandFeedback.cpp"
#include "ViewType.cpp"
#include "ViewType0.cpp"
#include "ViewType1.cpp"
#include "ViewType2.cpp"
#include "ViewType3.cpp"

#include "SynonymList.h"
#include "SynonymList.cpp"
#include "Dictionary.h"
#include "Dictionary.cpp"
#include "InputTokens.h"
#include "InputTokens.cpp"
#include "ChronoInterpreter.h"
#include "ChronoInterpreter.cpp"
#include "TaskPacker.h"
#include "TaskPacker.cpp"
#include "CommandPacker.h"
#include "CommandPacker.cpp"
#include "Parser_Interface.h"
#include "Parser_Interface.cpp"
#include "Parser.h"
#include "Parser.cpp"

#endif
```
###### ViewTypeTest\TesterHeader.h
``` h
#ifndef TESTMODE 

#else
#pragma once
#include "Exception_CorruptedFile.cpp"
#include "Exception_ExceededParameterLimit.cpp"
#include "Exception_FileCannotOpen.cpp"
#include "Exception_FirstTimeUser.cpp"
#include "Exception_InvalidCommand.cpp"
#include "Exception_CommandScroll.cpp"

#include "Logic.cpp"
#include "Commons.cpp"
#include "Task.cpp"
#include "Command.cpp"
#include "Command_Add.cpp"
#include "Command_Clear.cpp"
#include "Command_Edit.cpp"
#include "Command_Exit.cpp"
#include "Command_Help.cpp"
#include "Command_Invalid.cpp"
#include "Command_Redo.cpp"
#include "Command_Scroll.cpp"
#include "Command_SaveDirectory.cpp"
#include "Command_Search.cpp"
#include "Command_Undo.cpp"
#include "Command_ViewType.cpp"

#include "Memory.h"
#include "Memory.cpp"
#include "Settings.h"
#include "Settings.cpp"
#include "RAM.h"
#include "RAM.cpp"
#include "Storage.h"
#include "Storage.cpp"

#include "UserInterface.cpp"
#include "CommandFeedback.cpp"
#include "ViewType.cpp"
#include "ViewType0.cpp"
#include "ViewType1.cpp"
#include "ViewType2.cpp"
#include "ViewType3.cpp"

#include "SynonymList.h"
#include "SynonymList.cpp"
#include "Dictionary.h"
#include "Dictionary.cpp"
#include "InputTokens.h"
#include "InputTokens.cpp"
#include "ChronoInterpreter.h"
#include "ChronoInterpreter.cpp"
#include "TaskPacker.h"
#include "TaskPacker.cpp"
#include "CommandPacker.h"
#include "CommandPacker.cpp"
#include "Parser_Interface.h"
#include "Parser_Interface.cpp"
#include "Parser.h"
#include "Parser.cpp"

#endif
```
###### ViewTypeTest\ViewType Unit Test.cpp
``` cpp
#include "stdafx.h"
#include "CppUnitTest.h"
#include "TesterHeader.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace ViewTypeTest{		
    TEST_CLASS(ViewType0CLASS) {		
public:
    TEST_METHOD(ViewType0_getTaskString) {
        Task* task;
        ViewType0 testView;
        string expectedString = "read book (home) (13:00 19/8/2016 - 16:00 21/8/2016)";
        string actualString;

        task = new Task("read book" , 20160819 , 20160821 , 1300 , 1600 , "home");
        actualString = testView.getTaskString(task);
        Assert::AreEqual(expectedString, actualString);
    }

    TEST_METHOD(ViewType0_CreateDisplayList) {
        vector<string> actualDisplayList;
        int i = 0;
        ViewType0 testView;
        list<Task*> ls;
        string expectedString[6] = { 
            "1. read book (college) <No deadline>",
            "2. read book (home) (13:00 21/8/2016)", 
            "3. read book (home) (13:00 19/8/2016 - 16:00 21/8/2016)",             
            "4. read book (home) (21/9/2016)",
            "5. read book (college) (1:00 - 2:00 22/9/2016)",
            "6. read book (1:00 - 2:00 23/10/2016)"

        };
        ls.push_back(new Task("read book" , NO_DATE , NO_DATE , NO_TIME , NO_TIME , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20160821 , NO_TIME , 1300 , "home"));
        ls.push_back(new Task("read book" , 20160819 , 20160821 , 1300 , 1600 , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160921 , NO_TIME , NO_TIME , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160922 , 100 , 200 , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20161023 , 100 , 200 , ""));

        testView._taskList = &ls;

        actualDisplayList = testView.createDisplayList();

        vector<string>::iterator displayListIter = actualDisplayList.begin();

        while(displayListIter != actualDisplayList.end()) {
            Assert::AreEqual(expectedString[i], *displayListIter);
            i++;
            displayListIter++;
        }

    }

    TEST_METHOD(ViewType0_CreateSearchList) {
        vector<string> actualDisplayList;
        int i = 0;
        ViewType0 testView;
        list<Task*> ls;
        string expectedString[6] = { 
            "1. read book (college) <No deadline>",
            "2. read book (home) (13:00 21/8/2016)", 
            "3. read book (home) (13:00 19/8/2016 - 16:00 21/8/2016)",             
            "4. read book (home) (21/9/2016)",
            "5. read book (college) (1:00 - 2:00 22/9/2016)",
            "6. read book (1:00 - 2:00 23/10/2016)"

        };
        ls.push_back(new Task("read book" , NO_DATE , NO_DATE , NO_TIME , NO_TIME , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20160821 , NO_TIME , 1300 , "home"));
        ls.push_back(new Task("read book" , 20160819 , 20160821 , 1300 , 1600 , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160921 , NO_TIME , NO_TIME , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160922 , 100 , 200 , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20161023 , 100 , 200 , ""));

        testView._taskList = &ls;

        actualDisplayList = testView.createSearchList();

        vector<string>::iterator displayListIter = actualDisplayList.begin();

        while(displayListIter != actualDisplayList.end()) {
            Assert::AreEqual(expectedString[i], *displayListIter);
            i++;
            displayListIter++;
        }

    }
    };

    TEST_CLASS(ViewType1CLASS) {
public:

    TEST_METHOD(ViewType1_getTaskString) {
        Task* task;
        ViewType1 testView;
        string expectedString = "read book (home) (1:00pm 19-Aug - 4:00pm 21-Aug)";
        string actualString;

        task = new Task("read book" , 20160819 , 20160821 , 1300 , 1600 , "home");
        actualString = testView.getTaskString(task);
        Assert::AreEqual(expectedString, actualString);
    }

    TEST_METHOD(ViewType1_CreateDisplayList) {
        vector<string> actualDisplayList;
        int i = 0;
        ViewType *testView;
        list<Task*> ls;
        string expectedString[] = { 
            "<No Deadlines>",
            "1. read book (college) <No deadline>",
            "",
            "<Past>",
            "",
            "<TODAY>",
            "2. read book (home) (1:00pm Today)",
            "3. read book (home) (1:00pm 19-Aug - 4:00pm Today)",  
            "",
            "<This Week>",
            "",
            "<Next Week>",
            "",
            "<Future>",
            "4. read book (home) (21-Sep)",
            "5. read book (college) (1:00am - 2:00am 22-Sep)",
            "6. read book (1:00am - 2:00am 23-Oct)"
        };
        ls.push_back(new Task("read book" , NO_DATE , NO_DATE , NO_TIME , NO_TIME , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20160821 , NO_TIME , 1300 , "home"));
        ls.push_back(new Task("read book" , 20160819 , 20160821 , 1300 , 1600 , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160921 , NO_TIME , NO_TIME , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160922 , 100 , 200 , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20161023 , 100 , 200 , ""));

        testView = new ViewType1(&ls , 20160821); //initiate marker = 0

        actualDisplayList = testView->createDisplayList();

        vector<string>::iterator displayListIter = actualDisplayList.begin();

        while(displayListIter != actualDisplayList.end()) {
            Assert::AreEqual(expectedString[i], *displayListIter);
            i++;
            displayListIter++;
        }

    }

    TEST_METHOD(ViewType1_CreateSearchList) {
        vector<string> actualDisplayList;
        int i = 0;
        ViewType1* testView;
        list<Task*> ls;
        string expectedString[] = { 
            "1. read book (college) <No deadline>",
            "2. read book (home) (1:00pm Today)",
            "3. read book (home) (1:00pm 19-Aug - 4:00pm Today)",  
            "4. read book (home) (21-Sep)",
            "5. read book (college) (1:00am - 2:00am 22-Sep)",
            "6. read book (1:00am - 2:00am 23-Oct)"

        };
        ls.push_back(new Task("read book" , NO_DATE , NO_DATE , NO_TIME , NO_TIME , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20160821 , NO_TIME , 1300 , "home"));
        ls.push_back(new Task("read book" , 20160819 , 20160821 , 1300 , 1600 , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160921 , NO_TIME , NO_TIME , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160922 , 100 , 200 , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20161023 , 100 , 200 , ""));

        testView = new ViewType1(&ls , 20160821);

        actualDisplayList = testView->createSearchList();

        vector<string>::iterator displayListIter = actualDisplayList.begin();

        while(displayListIter != actualDisplayList.end()) {
            Assert::AreEqual(expectedString[i], *displayListIter);
            i++;
            displayListIter++;
        }

    }	
    };

    TEST_CLASS(ViewType2CLASS) {
public:
    TEST_METHOD(ViewType2_getTaskString) {
        Task* task;
        ViewType2 testView;
        string expectedString = "read book (home) (1:00pm 19-Aug - 4:00pm 21-Aug)";
        string actualString;

        task = new Task("read book" , 20160819 , 20160821 , 1300 , 1600 , "home");
        actualString = testView.getTaskString(task);
        Assert::AreEqual(expectedString, actualString);
    }

    TEST_METHOD(ViewType2_CreateDisplayList) {
        vector<string> actualDisplayList;
        int i = 0;
        ViewType *testView;
        list<Task*> ls;
        string expectedString[] = { 
            "<No Deadlines, Past>",
            "1. read book (college) <No deadline>",
            "",
            "<TODAY>",
            "2. read book (home) (1:00pm Today)", 
            "3. read book (home) (1:00pm 19-Aug - 4:00pm Today)",
            "",
            "<This Week>",
            "",
            "<Next Week>",
            "",
            "<Future>",
            "4. read book (home) (21-Sep)",
            "5. read book (college) (1:00am - 2:00am 22-Sep)",
            "6. read book (1:00am - 2:00am 23-Oct)"  
        };
        ls.push_back(new Task("read book" , NO_DATE , NO_DATE , NO_TIME , NO_TIME , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20160821 , NO_TIME , 1300 , "home"));
        ls.push_back(new Task("read book" , 20160819 , 20160821 , 1300 , 1600 , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160921 , NO_TIME , NO_TIME , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160922 , 100 , 200 , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20161023 , 100 , 200 , ""));


        testView = new ViewType2(&ls , 20160821); //initiate marker = 0

        actualDisplayList = testView->createDisplayList();

        vector<string>::iterator displayListIter = actualDisplayList.begin();

        while(displayListIter != actualDisplayList.end()) {
            Assert::AreEqual(expectedString[i], *displayListIter);
            i++;
            displayListIter++;
        }

    }

    TEST_METHOD(ViewType2_CreateSearchList) {
        vector<string> actualDisplayList;
        int i = 0;
        ViewType2* testView;
        list<Task*> ls;
        string expectedString[6] = { 
            "1. read book (college) <No deadline>",
            "2. read book (home) (1:00pm Today)", 
            "3. read book (home) (1:00pm 19-Aug - 4:00pm Today)",
            "4. read book (home) (21-Sep)",
            "5. read book (college) (1:00am - 2:00am 22-Sep)",
            "6. read book (1:00am - 2:00am 23-Oct)"  
        };

        ls.push_back(new Task("read book" , NO_DATE , NO_DATE , NO_TIME , NO_TIME , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20160821 , NO_TIME , 1300 , "home"));
        ls.push_back(new Task("read book" , 20160819 , 20160821 , 1300 , 1600 , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160921 , NO_TIME , NO_TIME , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160922 , 100 , 200 , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20161023 , 100 , 200 , ""));

        testView = new ViewType2(&ls , 20160821);

        actualDisplayList = testView->createSearchList();

        vector<string>::iterator displayListIter = actualDisplayList.begin();

        while(displayListIter != actualDisplayList.end()) {
            Assert::AreEqual(expectedString[i], *displayListIter);
            i++;
            displayListIter++;
        }

    }

    };

    TEST_CLASS(ViewType3CLASS) {
public:
    TEST_METHOD(ViewType3_getTaskString) {
        Task* task;
        ViewType3 testView;
        string expectedString = "read book (home) (1:00pm 19-Aug - 4:00pm 21-Aug)";
        string actualString;

        task = new Task("read book" , 20160819 , 20160821 , 1300 , 1600 , "home");
        actualString = testView.getTaskString(task);
        Assert::AreEqual(expectedString, actualString);
    }

    TEST_METHOD(ViewType3_CreateDisplayList) {
        vector<string> actualDisplayList;
        int i = 0;
        ViewType *testView;
        list<Task*> ls;
        string expectedString[] = { 
            "<No Deadlines, Past>",
            "1. read book (college) <No deadline>",
            "",
            "<TODAY>",
            "2. read book (home) (1:00pm Today)", 
            "3. read book (home) (1:00pm 19-Aug - 4:00pm Today)",
            "",
            "<Future>",
            "4. read book (home) (21-Sep)",
            "5. read book (college) (1:00am - 2:00am 22-Sep)",
            "6. read book (1:00am - 2:00am 23-Oct)"  
        };
        ls.push_back(new Task("read book" , NO_DATE , NO_DATE , NO_TIME , NO_TIME , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20160821 , NO_TIME , 1300 , "home"));
        ls.push_back(new Task("read book" , 20160819 , 20160821 , 1300 , 1600 , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160921 , NO_TIME , NO_TIME , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160922 , 100 , 200 , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20161023 , 100 , 200 , ""));


        testView = new ViewType3(&ls , 20160821); //initiate marker = 0

        actualDisplayList = testView->createDisplayList();

        vector<string>::iterator displayListIter = actualDisplayList.begin();

        while(displayListIter != actualDisplayList.end()) {
            Assert::AreEqual(expectedString[i], *displayListIter);
            i++;
            displayListIter++;
        }

    }

    TEST_METHOD(ViewType3_CreateSearchList) {
        vector<string> actualDisplayList;
        int i = 0;
        ViewType2* testView;
        list<Task*> ls;
        string expectedString[6] = { 
            "1. read book (college) <No deadline>",
            "2. read book (home) (1:00pm Today)", 
            "3. read book (home) (1:00pm 19-Aug - 4:00pm Today)",
            "4. read book (home) (21-Sep)",
            "5. read book (college) (1:00am - 2:00am 22-Sep)",
            "6. read book (1:00am - 2:00am 23-Oct)"  
        };

        ls.push_back(new Task("read book" , NO_DATE , NO_DATE , NO_TIME , NO_TIME , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20160821 , NO_TIME , 1300 , "home"));
        ls.push_back(new Task("read book" , 20160819 , 20160821 , 1300 , 1600 , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160921 , NO_TIME , NO_TIME , "home"));
        ls.push_back(new Task("read book" , NO_DATE , 20160922 , 100 , 200 , "college"));
        ls.push_back(new Task("read book" , NO_DATE , 20161023 , 100 , 200 , ""));

        testView = new ViewType2(&ls , 20160821);

        actualDisplayList = testView->createSearchList();

        vector<string>::iterator displayListIter = actualDisplayList.begin();

        while(displayListIter != actualDisplayList.end()) {
            Assert::AreEqual(expectedString[i], *displayListIter);
            i++;
            displayListIter++;
        }

    }

    };
}
```
