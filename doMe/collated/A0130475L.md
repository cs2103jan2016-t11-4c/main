# A0130475L
###### \Settings.cpp
``` cpp
#include "Settings.h"
const string Settings::FILE_SETTINGS_NAME = "settings.txt";
const string Settings::DEFAULT_TEXT_FILE_NAME = "doMe.txt";
const int Settings::DEFAULT_WINDOWS_WIDTH = 80;
const int Settings::DEFAULT_WINDOWS_LENGTH = 25; 

Settings* Settings::_instance = 0;

Settings* Settings::getInstance() {
    if (_instance == 0) {
        _instance = new Settings;
    }
    return _instance;
}

Settings::Settings(void) {
    _textFileName = DEFAULT_TEXT_FILE_NAME;
    _viewType = 0;
    _width = DEFAULT_WINDOWS_WIDTH;
    _length = DEFAULT_WINDOWS_LENGTH;
}

Settings::~Settings(void) {
}

/****************************************************************/

void Settings::loadSettings() {
    Storage* storage;
    storage = Storage::getInstance();
    try {
        ifstream readFile(FILE_SETTINGS_NAME);
        if(readFile.is_open()) {
            settingsLoadVector(storage->retrieveData(FILE_SETTINGS_NAME));
        } else {
            saveSettings();
        }
    } catch (Exception_FileCannotOpen e) {
        saveSettings();
    }
}

void Settings::saveSettings() {
    Storage* storage;
    storage = Storage::getInstance();
    storage->saveData(settingsGetVector() ,FILE_SETTINGS_NAME);
}

/****************************************************************/

void Settings::settingsLoadVector(vector<string> &existingData) {
    int i = 0;

    _textFileName = existingData[i];
    _saveDirectory = existingData[i+1];
    _viewType = stringToInteger(existingData[i+2]);
    _width = stringToInteger(existingData[i+3]);
    _length = stringToInteger(existingData[i+4]);

}

vector<string> Settings::settingsGetVector() {
    vector<string> updatedData;

    updatedData.push_back(_textFileName);
    updatedData.push_back(_saveDirectory);
    updatedData.push_back(integerToString(_viewType));
    updatedData.push_back(integerToString(_width));
    updatedData.push_back(integerToString(_length));
    return updatedData;
}

/****************************************************************/

bool Settings::changeSaveDirectory(string directory) {
    string newDirectory;
    newDirectory = createValidFileDirectoryString(directory);
    if(checkValidityOfDirectory(newDirectory)) {
        _saveDirectory = newDirectory;
        saveSettings(); //adding saveSettings() to all setter functions in Settings class; some redundancy may need further refactoring -joan
        return true;   
    } else {
        return false;
    }
}

bool Settings::changeViewType(int newViewType) {
    if((newViewType >= 0) && (newViewType <= 3)) {
        _viewType = newViewType;
        saveSettings(); //adding saveSettings() to all setter functions in Settings class; some redundancy may need further refactoring -joan
        return true;
    } else {
        return false;
    }
}

void Settings::changeWindowSize(int column, int row) {
    _width = column;
    _length = row;
    saveSettings();
}

/****************************************************************/

string Settings::getSaveDirectory() {
    return (_saveDirectory /*+ _textFileName*/);   //getSaveDirectory() should return the main directory w/o specific txt filename so that 
    //it can be generalised for settings.txt & doMe.txt & logs.txt etc etc
    //pre-condition: all these .txt files must be in same directory
}

int Settings::getViewType() {
    return _viewType;
}

string Settings::getTextFileName() {
    return _textFileName;
}

void Settings::getWindowSize(int& width, int& length) {
    width = _width;
    length = _length;
}

/****************************************************************/

string Settings::integerToString(int integer) {
    ostringstream word;
    word << integer;
    return word.str();
}

int Settings::stringToInteger(string& text) {
    stringstream ss(text);
    int integer;

    ss >> integer;

    return integer;
}

/****************************************************************/

//helper function to make correct format of save directory
string Settings::createValidFileDirectoryString(string directory) {
    string fileSeparator= "\\";
    if(directory.find_last_of("\\")+1 == directory.size()) {
        return directory;
    } else {
        return directory + fileSeparator;
    }
}

//https://msdn.microsoft.com/en-us/library/windows/desktop/bb773584(v=vs.85).aspx
bool Settings::checkValidityOfDirectory(const string& directory) {
    DWORD ftyp = GetFileAttributesA(directory.c_str());
    if (ftyp == INVALID_FILE_ATTRIBUTES) {
        return false;  
    }
    if (ftyp & FILE_ATTRIBUTE_DIRECTORY) {
        return true;   
    }

    return false;    
}
```
###### \UserInterface.cpp
``` cpp
#include "UserInterface.h"

const string UserInterface::SYSTEM_MODE_CON = "mode CON: COLS=%d lines=%d";
const string UserInterface::SYSTEM_COLOUR = "Color 0F";
const char UserInterface::MESSAGE_BOX_CHARACTER = '=';
const string UserInterface::MESSAGE_VOID_STRING = "";
const string UserInterface::MESSAGE_WELCOME = "Welcome to doMe. Your programme is ready for use.";
unsigned int UserInterface::DISPLAY_WIDTH = 80;
unsigned int UserInterface::DISPLAY_LENGTH = 25;

const string UserInterface::MESSAGE_FIRST_TIME = "This is your first time using this programme.";
const string UserInterface::MESSAGE_SAVE_FILE_NAME = "Input your save file name: ";
const string UserInterface::MESSAGE_SET_SAVE_FILE_DIRECTORY_PROMPT = "Set your save file directory: ";
const string UserInterface::MESSAGE_EMPTY_SAVE_FILE_DIRECTORY = "Your file is save at the current directory.";
const string UserInterface::MESSAGE_TIP_SAVE_FILE_DIRECTORY = "You can change your directory later.";
const string UserInterface::MESSAGE_COMMAND_PROMPT = "command: ";

const string UserInterface::COLOUR_DEFAULT = "DEFAULT";
const string UserInterface::COLOUR_NEW = "NEW";
const string UserInterface::COLOUR_DONE = "DONE";
const string UserInterface::COLOUR_SEARCH = "SEARCH";
const string UserInterface::COLOUR_HELP = "HELP";

const string UserInterface::MESSAGE_HELP_TIPS[] = { 
    "add <task description>", 
    "delete <index>",
    "clear",
    "edit <index> <task description>",
    "search <keyword>",
    "change <directory>",
    "undo",
    "redo",
    "change directory <directory>",
    "viewtype <index>",
    "help",
    "exit"
}; 

UserInterface::UserInterface(void) {
    system(SYSTEM_COLOUR.c_str());
    COORD windowSize;
    windowSize = GetLargestConsoleWindowSize(GetStdHandle(STD_OUTPUT_HANDLE));

    _maxWindowWidth = windowSize.X;
    _maxWindowLength = windowSize.Y;

    _commandFeedback = Command_Feedback::getInstance();
    _logic = Logic::getInstance();
    _memory = Memory::getInstance();
    _taskList = _memory->ramGetTaskList();
}

UserInterface::~UserInterface(void) {
}

/****************************************************************/

void UserInterface::setEnvironment() {
    setConsoleColorDefault();
    printProgramWelcomePage();
    vector<string> welcomeStringVector;

    try {
        _memory->loadSettings();
    } catch(Exception_FileCannotOpen e) {
        welcomeStringVector.push_back(e.getString());
    }
    try {
        _memory->loadRam();
    } catch(Exception_FileCannotOpen e) {
        welcomeStringVector.push_back(e.getString());
    }

    if(welcomeStringVector.empty()) {
        welcomeStringVector.push_back(MESSAGE_WELCOME);
    }

    int length,width;
    _memory->getWindowSize(width,length);
    resizeWindow(width,length);

    printNotificationWelcome(welcomeStringVector);
}

void UserInterface::printProgramWelcomePage() {
    resizeWindow(DISPLAY_WIDTH,DISPLAY_LENGTH);
    string space = "               ";
    cout << endl;
    cout << endl;
    cout << endl;
    cout << endl;
    cout << endl;
    cout << endl;
    cout << endl;
    cout << space; cout << "                   Welcome to" << endl; 
    cout << space; cout << "      _         __  __                          " << endl;
    cout << space; cout << "     | |       |  \\/  |                         " << endl;
    cout << space; cout << "   __| |  ___  | \\  / |  ___     ___ __  __ ___ " << endl;
    cout << space; cout << "  / _` | / _ \\ | |\\/| | / _ \\   / _ \\  \\/ // _ \\" << endl;
    cout << space; cout << " | (_| || (_) || |  | ||  __/ _|  __/ >  <|  __/" << endl;
    cout << space; cout << "  \\__,_| \\___/ |_|  |_| \\___|(_)\\___|/_/\\_\\___|" << endl;

    cout << endl;
    cout << space; cout << "          <Press any key to continue>" << endl;
    cout << endl << endl << endl << endl << endl << endl << endl << endl << endl;
    _getch();
}

void UserInterface::printNotificationWelcome(vector<string> welcomeStringVector) {
    printDefaultDisplay();
    vector<string>::iterator welcomeStringIter = welcomeStringVector.begin();
    while(welcomeStringIter != welcomeStringVector.end()){
        showToUser(*welcomeStringIter);
        welcomeStringIter++;
    }
}

/****************************************************************/

void UserInterface::printPromptCommand() {
    showToUserMessageBox();
    cout << MESSAGE_COMMAND_PROMPT;
}

string UserInterface::getStringCommand() {
    string command;
    printPromptCommand();
    getline(cin, command);
    return command;
}

void UserInterface::executeCommandUntilExit() {
    string stringCommand;
    Command* command;

    do {
        try {
            stringCommand = getStringCommand();
            LOG(__FILE__,"User enters: \" " + stringCommand + "\"");
            command = _logic->executeCommand(stringCommand);

            printMessageDisplay(command);
            printExecutionMessage(command, VALID_MESSAGE);
        } catch(Exception_InvalidCommand e) {
            command = e.getCommand();
            printMessageDisplay(command);
            printExecutionMessage(command, INVALID_MESSAGE);

        }
    } while(command->getCommandType() != EXIT);      
}

void UserInterface::printMessageDisplay(Command* command) {

    CommandType commandType = command->getCommandType();

    switch(commandType) {
    case SEARCH:
        _lastDisplayType = SEARCH_DISPLAY;
        printDisplayType(SEARCH_DISPLAY);
        break;
    case HELP:
        _lastDisplayType = HELP_DISPLAY;
        printDisplayType(HELP_DISPLAY);
        break;
    case EXIT:
        break;
    case INVALID:
        printDisplayType(_lastDisplayType);
        break;
    case REDO:   
        printMessageDisplay(command->getRedoneCommand());
        break;
    default:
        _lastDisplayType = DEFAULT_DISPLAY;
        printDisplayType(DEFAULT_DISPLAY);
        break;
    }
}

void UserInterface::printDisplayType(DisplayType display) {
    switch(display) {
    case SEARCH_DISPLAY:
        printSearchDisplay();
        break;
    case HELP_DISPLAY:
        printHelpDisplay();
        break;
    default:
        printDefaultDisplay();
        break;
    }
}

void UserInterface::printDefaultDisplay() {
    printTaskList(DATE, _memory->getViewType());
}

void UserInterface::printSearchDisplay() {
    printSearchList(DATE, _memory->getViewType());
}

void UserInterface::printHelpDisplay() {
    printHelpList(DATE, _memory->getViewType());
}

void UserInterface::printExecutionMessage(Command* executionMessage, CommandOutcome commandOutcome) {
    string message;
    message = _commandFeedback->getCommandFeedback(executionMessage, commandOutcome, _memory->getViewType());
    showToUser(message);

}

/****************************************************************/

void UserInterface::printTaskList(int currentDate, int viewType) {
    ViewType* taskListType;
    vector<string> displayList;
    vector<string> colourCoding;

    switch(viewType) {
    case 1:
        taskListType = new ViewType1(_taskList , currentDate);
        break;
    case 2:
        taskListType = new ViewType2(_taskList , currentDate);
        break;
    case 3:
        taskListType = new ViewType3(_taskList , currentDate);
        break;
    default:
        taskListType = new ViewType(_taskList , currentDate);
        break;
    }
    displayList = taskListType->createDisplayList();
    colourCoding = taskListType->getColourCoding();

    displayList = createDisplayBox(displayList);
    colourCoding = synchronizeColourCodingWithDisplayBox(colourCoding);

    printList(displayList, colourCoding);
    delete taskListType;
}

void UserInterface::printSearchList(int currentDate, int viewType) {
    ViewType* taskListType;

    switch(viewType) {
    case 1:
        taskListType = new ViewType1(_taskList);
        break;
    case 2:
        taskListType = new ViewType2(_taskList);
        break;
    case 3:
        taskListType = new ViewType3(_taskList , currentDate);
        break;
    default:
        taskListType = new ViewType(_taskList);
        break;
    }

    changeListColour(COLOUR_SEARCH);
    printList(createDisplayBox(taskListType->createSearchList()));
    //changeListColour(COLOUR_DEFAULT);

    delete taskListType;
}

void UserInterface::printHelpList(int currentDate, int viewType) {
    size_t size = (sizeof(MESSAGE_HELP_TIPS)/sizeof(*MESSAGE_HELP_TIPS));
    vector<string> helpList(MESSAGE_HELP_TIPS,MESSAGE_HELP_TIPS+size);

    changeListColour(COLOUR_HELP);
    printList(createDisplayBox(helpList));
}

/****************************************************************/

void UserInterface::printList(vector<string> displayList) {
    vector<string>::iterator displayListIter = displayList.begin();

    while(displayListIter != displayList.end()) {
        showToUser(*displayListIter);
        displayListIter++;
    }
}

void UserInterface::printList(vector<string> displayList, vector<string> colourCoding) {
    vector<string>::iterator displayListIter = displayList.begin();
    vector<string>::iterator colourCodingIter = colourCoding.begin();

    while(displayListIter != displayList.end()) {
        changeListColour(*colourCodingIter);
        showToUser(*displayListIter);
        displayListIter++;
        if(colourCodingIter != colourCoding.end()-1) {
            colourCodingIter++;
        }
    }
}

/****************************************************************/

vector<string> UserInterface::createDisplayBox(vector<string> displayList) {
    vector<string>::iterator displayListIter;
    string messageBox;

    setWindowsRowsColumns(displayList.size()+2);
    messageBox.assign(DISPLAY_WIDTH,MESSAGE_BOX_CHARACTER);
    messageBox.pop_back();

    displayList.insert(displayList.begin(),messageBox);
    displayList.insert(displayList.begin(),MESSAGE_VOID_STRING);
    displayListIter = displayList.begin();
    displayListIter++;

    while(displayList.size() < DISPLAY_LENGTH) {
        displayList.push_back(MESSAGE_VOID_STRING);
    }

    displayList.insert(displayList.end(),messageBox);
    return displayList;
}

vector<string> UserInterface::synchronizeColourCodingWithDisplayBox(vector<string> colourCoding) {
    int i = 0;
    while(i < 2) {
        colourCoding.insert(colourCoding.begin(),COLOUR_DEFAULT);
        i++;
    }
    colourCoding.insert(colourCoding.end(),COLOUR_DEFAULT);
    return colourCoding;
}

void UserInterface::showToUser(string message) {
    cout << message << endl;
}

void UserInterface::showToUserMessageBox() {
    string messageBox;
    //setWindowsRowsColumns(0);
    messageBox.assign(DISPLAY_WIDTH,MESSAGE_BOX_CHARACTER);
    messageBox.pop_back();

    showToUser(messageBox);
}

/****************************************************************/

void UserInterface::resizeWindow(int width, int length) {
    sprintf_s(buffer, SYSTEM_MODE_CON.c_str(), width, length);
    system(buffer);
}

void UserInterface::setWindowsRowsColumns(int size) {
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    int width;
    int length;

    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
    width = csbi.srWindow.Right - csbi.srWindow.Left + 1;
    length = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;

    DISPLAY_WIDTH = width;
    DISPLAY_LENGTH = length - 4;

    while((size < _maxWindowLength) && (size > DISPLAY_LENGTH)) {
        if(size < _maxWindowLength) {
            if(size > DISPLAY_LENGTH) {
                resizeWindow(width,length+1);
                DISPLAY_LENGTH++;
            }
        } 
    }
    _memory->changeWindowSize(DISPLAY_WIDTH,DISPLAY_LENGTH + 4);
}

/****************************************************************/

void UserInterface::changeListColour(string colourCoding) {
    if(colourCoding == COLOUR_NEW) {
        setConsoleColor(BLACK, LIGHT_RED);
        return;
    } else {
        if(colourCoding == COLOUR_DONE) {
            setConsoleColor(BLACK, GRAY);
            return;
        } else {
            if(colourCoding == COLOUR_SEARCH) {
                setConsoleColor(BLACK, LIGHT_GREEN);
                return;
            } else {
                if(colourCoding == COLOUR_HELP) {
                    setConsoleColor(BLACK, LIGHT_YELLOW);
                    return;
                }
            }
        }
    }
    setConsoleColorDefault();
}

void UserInterface::setConsoleColor(int background, int foreground) {
    HANDLE  hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    int colour = background * 16 + foreground;
    SetConsoleTextAttribute(hConsole, colour);
}

void UserInterface::setConsoleColorDefault() {
    setConsoleColor(BLACK, LIGHT_WHITE);
}

/*************************Unused*********************************/
/****************************************************************/

void UserInterface::printPromptHelp() {
    size_t size = (sizeof(MESSAGE_HELP_TIPS)/sizeof(*MESSAGE_HELP_TIPS));
    vector<string> helpList(MESSAGE_HELP_TIPS,MESSAGE_HELP_TIPS+size);
    vector<string>::iterator helpListIter = helpList.begin();

    while(helpListIter!= helpList.end()) {
        showToUser(*helpListIter);
        helpListIter++;
    }
}
```
###### \UserInterface.h
``` h
#pragma once
#include <string>
#include <fstream>
#include <iostream>
#include <sstream>
#include <vector>
#include <list>
#include <windows.h>
#include <conio.h>
#include <ctime>
#include <assert.h>

#include "Logic.h"
#include "Memory.h"
#include "Command_Feedback.h"
#include "Command.h"
#include "Task.h"
#include "ViewType.h"
#include "ViewType1.h"
#include "ViewType2.h"
#include "ViewType3.h"

using namespace std;

class UserInterface {

public:
    //UserInterface(void);
    UserInterface();
    ~UserInterface(void);

    void setEnvironment();
    void executeCommandUntilExit();

#ifndef TESTMODE 
private: 
#else 
public: 
#endif
    enum DisplayType {
        DEFAULT_DISPLAY, SEARCH_DISPLAY, HELP_DISPLAY
    };
    DisplayType _lastDisplayType;
    Logic* _logic;
    Memory* _memory;
    Command_Feedback* _commandFeedback;
    list<Task*>* _taskList;


    int _maxWindowWidth;
    int _maxWindowLength;
    char buffer[255];

    //Initial programme page
    void printProgramWelcomePage();
    void printNotificationWelcome(vector<string> welcomeStringVector);

    //prompts
    void printPromptCommand();	
    void printPromptHelp();

    //Message display
    void printMessageDisplay(Command* command);
    void printDisplayType(DisplayType display);
    void printDefaultDisplay();
    void printSearchDisplay();
    void printHelpDisplay();

    void printTaskList(int currentDate ,int viewType);
    void printSearchList(int currentDate, int viewType);
    void printHelpList(int currentDate, int viewType);

    //notification
    void printExecutionMessage(Command* executionMessage, CommandOutcome commandOutcome);

    //helper
    void showToUser(string message);
    void showToUserMessageBox();
    string getStringCommand();
    vector<string> createDisplayBox(vector<string> displayList);
    vector<string> synchronizeColourCodingWithDisplayBox(vector<string> colourCoding);
    void printList(vector<string> displayList); 
    void printList(vector<string> displayList, vector<string> colourCoding);

    //window size related function
    void resizeWindow(int width, int length);
    void setWindowsRowsColumns(int size);

    //window text colour
    enum Colour {
        BLACK, BLUE, GREEN, AQUA, RED, PURPLE, YELLOW, WHITE, GRAY, LIGHT_BLUE, LIGHT_GREEN, LIGHT_AQUA, LIGHT_RED, LIGHT_PURPLE, LIGHT_YELLOW, LIGHT_WHITE
    };
    static const string COLOUR_DEFAULT;
    static const string COLOUR_NEW;
    static const string COLOUR_DONE;
    static const string COLOUR_SEARCH;
    static const string COLOUR_HELP;

    void changeListColour(string colourCoding);
    void setConsoleColor(int background, int foreground);
    void setConsoleColorDefault();

    static const string SYSTEM_MODE_CON;
    static const string SYSTEM_COLOUR;
    static const string MESSAGE_WELCOME;
    static const char MESSAGE_BOX_CHARACTER;
    static const string MESSAGE_VOID_STRING; 
    static unsigned int DISPLAY_WIDTH;
    static unsigned int DISPLAY_LENGTH;

    static const string MESSAGE_FIRST_TIME;
    static const string MESSAGE_SAVE_FILE_NAME;
    static const string MESSAGE_SET_SAVE_FILE_DIRECTORY_PROMPT;
    static const string MESSAGE_EMPTY_SAVE_FILE_DIRECTORY;
    static const string MESSAGE_TIP_SAVE_FILE_DIRECTORY;
    static const string MESSAGE_COMMAND_PROMPT;
    static const string MESSAGE_HELP_TIPS[];
};

```
###### \ViewType.cpp
``` cpp
#include "ViewType.h"

const string ViewType::MESSAGE_DISPLAY_CONTENTS = "%d. %s";
const string ViewType::MESSAGE_DATE_SEPERATOR = "/";
const string ViewType::MESSAGE_TIME_SEPERATOR = ":";
const string ViewType::MESSAGE_TIMING_SEPERATOR = "- ";
const string ViewType::MESSAGE_VOID_STRING = "";
const string ViewType::MESSAGE_SPACE_STRING = " ";
const string ViewType::MESSAGE_BRACKETS = "(%s)";
const string ViewType::MESSAGE_FLOATING_TASK = "<No deadline>";
const string ViewType::MESSAGE_EMPTY_LIST = "<list is empty!>";

const string ViewType::COLOUR_DEFAULT = "DEFAULT";
const string ViewType::COLOUR_NEW = "NEW";
const string ViewType::COLOUR_DONE = "DONE";

ViewType::ViewType(void) {
}

ViewType::ViewType(list<Task*> *taskList) {
    _taskList = taskList;
    _currentDate = 0;
}

ViewType::ViewType(list<Task*> *taskList, int currentDate) {
    _taskList = taskList;
    _currentDate = currentDate;
}

ViewType::~ViewType(void) {
}

/****************************************************************/

vector<string> ViewType::createDisplayList() {
    if((*_taskList).empty()) {
        _displayList.push_back(MESSAGE_EMPTY_LIST);
    } else {
        list<Task*>::iterator taskListIter = ((*_taskList).begin());
        string complimentaryString;
        Memory* memory;
        int index = 1;

        memory = Memory::getInstance();
        Task* recentTask = memory->ramGetLastModifiedTask();

        while(taskListIter != (*_taskList).end()) {
            complimentaryString = getComplimentaryString(*taskListIter);
            if(complimentaryString != MESSAGE_VOID_STRING) {
                _displayList.push_back(complimentaryString);
                _colourCoding.push_back(COLOUR_DEFAULT);
            }

            if(complimentaryString != MESSAGE_SPACE_STRING) {
                _colourCoding.push_back(colourCoderTag(*taskListIter, recentTask));
                _displayList.push_back(createTaskString(*taskListIter,index));
                index++;
                taskListIter++;
            }
        }
    }
    return _displayList;

}

string ViewType::colourCoderTag(Task* individualTask, Task* recentTask) {
    if(recentTask == individualTask) {
        return COLOUR_NEW;
    } else {
        if(individualTask->getDoneStatus() == true) {
            return COLOUR_NEW;
        }
    }
    return COLOUR_DEFAULT;
}

//search list without complimentary string
vector<string> ViewType::createSearchList() {
    if((*_taskList).empty()) {
        _displayList.push_back(MESSAGE_EMPTY_LIST);
    } else {
        list<Task*>::iterator taskListIter = (*_taskList).begin();
        int index = 1;

        while(taskListIter != (*_taskList).end()) {
            _displayList.push_back(ViewType::createTaskString(*taskListIter,index));
            index++;
            taskListIter++;
        }
    }
    return _displayList;
}

//create task string with index
string ViewType::createTaskString(Task* individualTask, int index) {
    string taskString;
    taskString = getTaskString(individualTask);

    sprintf_s(buffer, MESSAGE_DISPLAY_CONTENTS.c_str(),index, taskString.c_str());

    return buffer;
}

string ViewType::getTaskString(Task* individualTask) {
    string name = individualTask->getName();
    string location = individualTask->getLocation();
    string date1 = getDateTaskString(individualTask->getDate1());
    string date2 = getDateTaskString(individualTask->getDate2());
    string time1 = getTimeTaskString(individualTask->getTime1());
    string time2 = getTimeTaskString(individualTask->getTime2());

    string taskString = formatTaskString(name,date1,date2,time1,time2,location);

    return taskString;
}
/****************************************************************/

string ViewType::integerToString(int integer) {
    ostringstream oss;
    oss << integer;  
    return oss.str();
}

string ViewType::timeToString(string time) {
    string timeString = time;
    if(time.size() < 3) {
        timeString.insert(0,"0");
    }
    if(time.size()  < 2) {
        timeString.insert(0,"0");
    }
    return timeString;
}

/****************************************************************/
//default format of ordering: name - (location) time1 date1 - time2 date2
string ViewType::formatTaskString(string name , string date1 , string date2 , string time1 , string time2 , string location) {
    string taskString;
    string dateString;

    name = formateAddSpace(name);
    date1 = formateAddSpace(date1);
    date2 = formateAddSpace(date2);
    time1 = formateAddSpace(time1);
    time2 = formateAddSpace(time2);

    location = formateAddBracket(location);
    location = formateAddSpace(location);

    dateString = formateDateString(time1 + date1 , time2 + date2);
    taskString = name + location + dateString;

    //taskString.pop_back();
    return taskString;
}

string ViewType::formateAddSpace(string s) {
    if(!s.empty()) {
        return s + MESSAGE_SPACE_STRING;
    } 
    return s;
}

string ViewType::formateAddBracket(string s) {
    if(!s.empty()) {
        sprintf_s(buffer, MESSAGE_BRACKETS.c_str(), s.c_str());
        return buffer;
    }
    return s;
}

string ViewType::formateDateString(string s1, string s2) {
    string time;
    if((s1.empty()) && (s2.empty())) {
        return MESSAGE_FLOATING_TASK;
    }
    if((s1.empty()) || (s2.empty())) {
        time = s1 + s2;
        time.pop_back();
        sprintf_s(buffer, MESSAGE_BRACKETS.c_str(),time.c_str());
        return buffer;
    } else {
        time = s1 + MESSAGE_TIMING_SEPERATOR + s2;
        time.pop_back();
        sprintf_s(buffer, MESSAGE_BRACKETS.c_str(),time.c_str());
        return buffer;

    }
}

/****************************************************************/
/*Overriding functions*/
/****************************************************************/
//headers + additional lines to compliment to viewtype (default void)
string ViewType::getComplimentaryString(Task* individualTask) {
    return MESSAGE_VOID_STRING;
}

string ViewType::getDateTaskString(int date) {
    string dateString;
    string day;
    string month;
    string year;

    if(date > 0) {
        day = getDay(date);
        month = getMonth(date);
        year = getYear(date);
        dateString = day + MESSAGE_DATE_SEPERATOR + month + MESSAGE_DATE_SEPERATOR + year;

        return dateString;
    } else {
        return MESSAGE_VOID_STRING;
    }
}

string ViewType::getTimeTaskString(int time) {
    string timeString;

    if(time >= 0) {
        timeString = integerToString(time);
        timeString = timeToString(timeString);

        timeString.insert(timeString.size() - 2,MESSAGE_TIME_SEPERATOR);

        return timeString;
    } else {
        return MESSAGE_VOID_STRING;
    }
}

vector<string> ViewType::getColourCoding() {
    return _colourCoding;
}

/****************************************************************/

string ViewType::getDay(int date) {
    ostringstream oss;
    oss << date % 100;
    return oss.str();
}

string ViewType::getMonth(int date) {
    ostringstream oss;
    date = date / 100;
    oss << date % 100;
    return oss.str();
}

string ViewType::getYear(int date) {
    ostringstream oss;
    oss << date / 10000;
    return oss.str();
}

```
###### \ViewType1.cpp
``` cpp
#include "ViewType1.h"

const string ViewType1::MESSAGE_DISPLAY_HEADER = "Today's date is %s";
const string ViewType1::MESSAGE_NEW_LINE = "\n";
const string ViewType1::MESSAGE_AM = "am";
const string ViewType1::MESSAGE_PM = "pm";
const int ViewType1::TIME_STRING_INT = 4;//Meridiem size (am/pm) + 2
const int ViewType1::TIME_MIDDAY = 1200;


ViewType1::ViewType1(void) {
}

ViewType1::ViewType1(list<Task*> *taskList) {
    _taskList = taskList;
    _currentDate = 0;
    _headerMarker = 0;
}

ViewType1::ViewType1(list<Task*> *taskList, int currentDate) : ViewType(taskList,currentDate) {
    _headerMarker = 0;
}

ViewType1::~ViewType1(void) {
}

string ViewType1::getComplimentaryString(Task* individualTask) {
    int date;
    date = individualTask->getDate2();

    switch (_headerMarker) {
    case 0:
        sprintf_s(buffer, MESSAGE_DISPLAY_HEADER.c_str(), (getDateTaskString(_currentDate)).c_str());
        _headerMarker = 1;
        if(_currentDate < date) {
            _headerMarker = 2;
             return buffer + MESSAGE_NEW_LINE;
        } else {
        return buffer;
        break;
    }
    case 1:
        if(_currentDate < date) {    
            _headerMarker = 2;
            return MESSAGE_SPACE_STRING;
            break;
        } 
        break;
    }
    return MESSAGE_VOID_STRING;
}

string ViewType1::getTimeTaskString(int time) {
    string timeString;

    if(time >= 0) {
        if(time > TIME_MIDDAY) {
            time = time - TIME_MIDDAY;
            timeString = integerToString(time);
            timeString = timeString + MESSAGE_PM;
        } else {
            if(time < 100) {
                time = time + TIME_MIDDAY;
            } 

            timeString = integerToString(time);
            timeString = timeString + MESSAGE_AM;
        }
        timeString.insert(timeString.size() - TIME_STRING_INT, MESSAGE_TIME_SEPERATOR);
        return timeString;

    } else {
        return MESSAGE_VOID_STRING;
    }
}


```
###### \ViewType1.h
``` h
#pragma once
#include "ViewType.h"


class ViewType1 : public ViewType {
private:
    int _headerMarker;

    static const string MESSAGE_DISPLAY_HEADER;
    static const string MESSAGE_NEW_LINE;
    static const string MESSAGE_AM;
    static const string MESSAGE_PM;
    static const int TIME_STRING_INT;
    static const int TIME_MIDDAY;

    //overiding functions
    string getComplimentaryString(Task* individualTask);

public:
    ViewType1(void);
    ViewType1(list<Task*> *taskList);
    ViewType1(list<Task*> *taskList, int currentDate);
    ~ViewType1(void);

    string getTimeTaskString(int time);
};

```
###### \ViewType2.cpp
``` cpp
#include "ViewType2.h"

const string ViewType2::MESSAGE_DISPLAY_HEADER = "Today's date is %s";
const string ViewType2::MESSAGE_NEW_LINE = "\n";
const string ViewType2::MESSAGE_AM = "am";
const string ViewType2::MESSAGE_PM = "pm";
const string ViewType2::MESSAGE_TIMING_SEPERATOR = "-";
const int ViewType2::TIME_STRING_INT = 4;//Meridiem size (am/pm) + 2
const int ViewType2::TIME_MIDDAY = 1200;
const string ViewType2::MESSAGE_BOX = "======================================================================";
const string ViewType2::MESSAGE_MONTH[] = { 
    "Jan", 
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
}; 



ViewType2::ViewType2(void) {
}

ViewType2::ViewType2(list<Task*> *taskList) {
    _taskList = taskList;
    _currentDate = 0;
    _headerMarker = 0;
}

ViewType2::ViewType2(list<Task*> *taskList, int currentDate) : ViewType(taskList,currentDate) {
    _headerMarker = 0;
}

ViewType2::~ViewType2(void) {
}

/****************************************************************/

string ViewType2::getComplimentaryString(Task* individualTask) {
    int date;
    date = individualTask->getDate2();

    switch (_headerMarker) {
    case 0:
        sprintf_s(buffer, MESSAGE_DISPLAY_HEADER.c_str(), (getDateTaskString(_currentDate)).c_str());
        _headerMarker = 1;
        if(_currentDate < date) {
            _headerMarker = 2;
             return buffer + MESSAGE_NEW_LINE;
        } else {
        return buffer;
        break;
    }
    case 1:
        if(_currentDate < date) {    
            _headerMarker = 2;
            return MESSAGE_SPACE_STRING;
            break;
        } 
        break;
    }
    return MESSAGE_VOID_STRING;
}

/****************************************************************/

string ViewType2::getTimeTaskString(int time) {
    ViewType1 view;
    return view.getTimeTaskString(time);
}

string ViewType2::getDateTaskString(int date) {
    string dateString;
    string day;
    string month;
    string year;

    if(date > 0) {
        day = getDay(date);
        month = getMonth(date);
        //year = getYear(date);
        dateString = day + MESSAGE_TIMING_SEPERATOR + month;

        return dateString;
    } else {
        return MESSAGE_VOID_STRING;
    }
}

string ViewType2::getMonth(int date) {
    int month;
    date = date / 100;
    month = date % 100;
    assert((month <= 12) && (month > 0));

    return MESSAGE_MONTH[month-1];
}

```
###### \ViewType2.h
``` h
#pragma once
#include "ViewType.h"
#include "ViewType1.h"

class ViewType2 : public ViewType {
private:
    int _headerMarker;

    static const string MESSAGE_DISPLAY_HEADER;
    static const string MESSAGE_TIMING_SEPERATOR;
    static const string MESSAGE_NEW_LINE;
    static const string MESSAGE_AM;
    static const string MESSAGE_PM;
    static const int TIME_STRING_INT;
    static const int TIME_MIDDAY;
    static const string MESSAGE_BOX;

    static const string MESSAGE_MONTH_JANUARY;
    static const string MESSAGE_MONTH_FEBUARY;
    static const string MESSAGE_MONTH_MARCH;
    static const string MESSAGE_MONTH_APRIL;
    static const string MESSAGE_MONTH_MAY;
    static const string MESSAGE_MONTH_JUNE;
    static const string MESSAGE_MONTH_JULY;
    static const string MESSAGE_MONTH_AUGUST;
    static const string MESSAGE_MONTH_SEPTEMPER;
    static const string MESSAGE_MONTH_NOVEMBER;
    static const string MESSAGE_MONTH_DECEMBER;

    static const string MESSAGE_MONTH[];

    //overiding functions
    string getComplimentaryString(Task* individualTask);
   
public:
    ViewType2(void);
    ViewType2(list<Task*> *taskList);
    ViewType2(list<Task*> *taskList, int currentDate);
    ~ViewType2(void);

    string getDateTaskString(int date);
    string getTimeTaskString(int time);
    string getMonth(int date);

};

```
###### \Settings.h
``` h
#pragma once
#include <string>
#include <fstream>
#include <iostream>
#include <sstream>
#include <windows.h>
#include "Storage.h"
using namespace std;


class Settings {
public:
    static Settings* getInstance();

    //setter
    bool changeSaveDirectory(string directory); //API for Memory component
    bool changeViewType(int newViewType); //API for Memory compoent
    void changeWindowSize(int column, int row);
    //getter
    string getSaveDirectory();
    string getTextFileName();
    int getViewType();
    void getWindowSize(int& width, int& length);

    void loadSettings(); //placed in constructor of Settings; boolean return value to be reconsidered

#ifndef TESTMODE 
private: 
#else 
public: 
#endif

    static const string FILE_SETTINGS_NAME;
    static const string DEFAULT_TEXT_FILE_NAME;
    static const string SYSTEM_MODE_CON;
    static const int DEFAULT_WINDOWS_WIDTH;
    static const int DEFAULT_WINDOWS_LENGTH; 

    string _textFileName;
    string _saveDirectory;
    int _viewType; 
    int _width;
    int _length;
    char buffer[255];
    static Settings* _instance;

    Settings(void);
    ~Settings(void);

    void settingsLoadVector(vector<string> &existingData);
    vector<string> settingsGetVector();

    string createValidFileDirectoryString(string directory); //helper input return directory with "/"
    bool checkValidityOfDirectory(const string& directory); //might remove

    string integerToString(int integer);
    int stringToInteger(string& text);

    void saveSettings(); //placed in every setter function, in order save changes to settings.txt	

};

```
###### \Command_Feedback.cpp
``` cpp
#include "Command_Feedback.h"

const string Command_Feedback::DEFAULT_TEXT_FILE_NAME = "doMe.txt";
const string Command_Feedback::MESSAGE_VOID_STRING = "";

const string Command_Feedback::MESSAGE_ADD = "Added \"%s\" into %s";
//const string Command_Feedback::MESSAGE_EMPTY = "Your text file \"%s\" is currently empty.";
const string Command_Feedback::MESSAGE_DELETE = "Deleted \"%s\" from %s";
const string Command_Feedback::MESSAGE_EDIT = "Edited inputted task description to \"%s\"";
const string Command_Feedback::MESSAGE_CLEAR = "All contents cleared from the list in %s";
const string Command_Feedback::MESSAGE_SEARCH = "~Showing all results for \"%s\". Type \"exit\" to exit the search module~";
//const string Command_Feedback::MESSAGE_CLEAR_SEARCH = "All task with the search term \"%s\" is cleared.";
const string Command_Feedback::MESSAGE_CHANGE_FILE_DIRECTORY = "New save directory: %s";
const string Command_Feedback::MESSAGE_VIEW_TYPE = "Your current default view type is changed to (%d).";
const string Command_Feedback::MESSAGE_EXIT_SEARCH = "Exited search module.";
const string Command_Feedback::MESSAGE_HELP = "Showing available commands and how to use them.";
const string Command_Feedback::MESSAGE_REDO = "Redo - <%s>";

const string Command_Feedback::ERROR_INVALID_ADD = "Invalid (ADD) has been inputted.";
const string Command_Feedback::ERROR_INVALID_DELETE = "Invalid (DELETE) has been inputted.";
const string Command_Feedback::ERROR_INVALID_COMMAND_FORMAT = "Invalid command format has been inputted.";
const string Command_Feedback::ERROR_INVALID_COMMAND = "Invalid command has been inputted.";
const string Command_Feedback::ERROR_INVALID_VIEWTYPE = "Invalid (Viewtype) has been inputted.";
const string Command_Feedback::ERROR_INVALID_EDIT = "Invalid (EDIT) of task description.";
const string Command_Feedback::ERROR_INVALID_UNDO = "Unable to undo previous command.";
const string Command_Feedback::ERROR_INVALID_SAVE_FILE_DIRECTORY = "Invalid file directory.";

const string Command_Feedback::MESSAGE_UNDO_COMMAND = "Undo previous command.";
const string Command_Feedback::MESSAGE_UNDO_ADD = "Undo (ADD) of \"%s\"";
const string Command_Feedback::MESSAGE_UNDO_DELETE = "Undo (DELETE) of \"%s\"";
const string Command_Feedback::MESSAGE_UNDO_EDIT = "Undo (EDIT) of \"%s\"";
const string Command_Feedback::MESSAGE_UNDO_CLEAR = "Undo (CLEAR)";
const string Command_Feedback::MESSAGE_UNDO_VIEW_TYPE = "Undo (Viewtype) change of \"%d\"";
const string Command_Feedback::MESSAGE_UNDO_CHANGE_DIRECTORY = "Undo (Change Directory) of \"%s\"";

Command_Feedback* Command_Feedback::_instance = 0;

Command_Feedback* Command_Feedback::getInstance() {
    if (_instance == 0) {
        _instance = new Command_Feedback;
    }
    return _instance;
}

Command_Feedback::Command_Feedback(void) {
}

Command_Feedback::~Command_Feedback(void) {
}

/****************************************************************/

string Command_Feedback::getTaskString(Task* task, int viewType) {
    ViewType* taskListType;

    switch(viewType) {
    case 1:
        taskListType = new ViewType1();
        break;
    case 2:
        taskListType = new ViewType2();
        break;
    default:
        taskListType = new ViewType();
        break;
    }

    return taskListType->getTaskString(task);
}

string Command_Feedback::getCommandFeedback(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    CommandType commandType = executionMessage->getCommandType();

    switch(commandType) {
    case ADD:
        return getNotificationAdd(executionMessage, commandOutcome, viewType);
        break;
    case DISPLAY:
        //return "no display UI";
        break;
    case DEL:
        return getNotificationDelete(executionMessage, commandOutcome, viewType);
        break;
    case EDIT:
        return getNotificationEdit(executionMessage, commandOutcome, viewType);
        break;
    case CLEAR:
        return getNotificationClear(executionMessage, commandOutcome, viewType);
        break;
    case UNDO:
        return getNotificationUndo(executionMessage, commandOutcome, viewType);
        break;
    case REDO:
        return getNotificationRedo(executionMessage, commandOutcome, viewType);
        break;
    case SORT:
        //return "auto sort?";
        break;
    case SEARCH:
        return getNotificationSearchTerm(executionMessage, commandOutcome, viewType);
        break;
    case ENDSEARCH:
        return getNotificationEndSearch(executionMessage, commandOutcome, viewType);
        break;
    case VIEWTYPE:
        return getNotificationViewType(executionMessage, commandOutcome, viewType);
        break;
    case SAVEDIRECTORY:
        return getNotificationChangeSaveFileDirectory(executionMessage, commandOutcome, viewType);
        break;
    case EXIT:
        //showToUser("Do I even need a exiting message? Nope");
        break;
    case HELP:
        return getNotificationHelpPrompt(executionMessage, commandOutcome, viewType);
        break;
    case INVALID:
        return getNotificationInvalidCommand(executionMessage, commandOutcome, viewType);
        break;
    default:
        break;
    }
    return MESSAGE_VOID_STRING;
}

/****************************************************************/

string Command_Feedback::getNotificationUndo(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    Command* undoCommandMessage;
    CommandType commandType;

    switch(commandOutcome) {
    case VALID_MESSAGE:
        undoCommandMessage = executionMessage->getUndoneCommand();
        commandType = undoCommandMessage->getCommandType();
        switch(commandType) {
        case ADD:
            return undoNotificationAdd(undoCommandMessage, viewType);
            break;
        case DISPLAY:
            assert(0);
            //return "no display UI";
            break;
        case DEL:
            return undoNotificationDel(undoCommandMessage, viewType);
            break;
        case EDIT:
            return undoNotificationEdit(undoCommandMessage, viewType);
            break;
        case CLEAR:
            return undoNotificationClear(undoCommandMessage, viewType);
            break;
        case UNDO:
            assert(0);
            //return "Unable to undo a undo";
            break;
        case SORT:
            assert(0);
            //return "auto sort?";
            break;
        case SEARCH:
            //return "Can you even undo a search?";
            return validNotificationExitSearch();
            break;
        case ENDSEARCH:
            return getNotificationSearchTerm(undoCommandMessage, commandOutcome, viewType);
            //return "No undo exit";
            break;
        case VIEWTYPE:
            return undoNotificationViewType(undoCommandMessage, viewType);
            break;
        case SAVEDIRECTORY:
            return undoNotificationChangDirectory(undoCommandMessage, viewType);
            break;
        case EXIT:
            assert(0);
            break;
        case INVALID:
            return invalidNotificationUndo();
            break;
        }
    case INVALID_MESSAGE:
        return invalidNotificationUndo();
        break;
    }
    return MESSAGE_UNDO_COMMAND;
}

string Command_Feedback::getNotificationRedo(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    string redoString = getCommandFeedback(executionMessage->getRedoneCommand(), commandOutcome, viewType);
    sprintf_s(buffer, MESSAGE_REDO.c_str(),redoString.c_str());
    return buffer;
}

string Command_Feedback::getNotificationAdd(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    switch(commandOutcome) {
    case VALID_MESSAGE:
        return validNotificationAdd(executionMessage->getTask(), viewType, DEFAULT_TEXT_FILE_NAME);
        break;
    case INVALID_MESSAGE:
        return invalidNotificationAdd();
        break;
    }

}

string Command_Feedback::getNotificationDelete(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    switch(commandOutcome) {
    case VALID_MESSAGE:
        return validNotificationDelete(executionMessage->getTask(), viewType, DEFAULT_TEXT_FILE_NAME);
        break;
    case INVALID_MESSAGE:
        return invalidNotificationDelete();
        break;
    }
}

string Command_Feedback::getNotificationEdit(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    switch(commandOutcome) {
    case VALID_MESSAGE:
        return validNotificationEdit(executionMessage->getTask(), viewType);
        break;
    case INVALID_MESSAGE:
        return invalidNotificationEdit();
        break;
    }
}

string Command_Feedback::getNotificationClear(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    switch(commandOutcome) {
    case VALID_MESSAGE:
        return validNotificationClear(DEFAULT_TEXT_FILE_NAME);
        break;
    case INVALID_MESSAGE:
        return ERROR_INVALID_COMMAND;
        break;
    }
}

string Command_Feedback::getNotificationSearchTerm(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    string searchTerm;
    searchTerm = executionMessage->getSearchTerm();
    return validNotificationSearchTerm(searchTerm);
}

string Command_Feedback::getNotificationEndSearch(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    switch(commandOutcome) {
    case VALID_MESSAGE:
        return validNotificationExitSearch();
        break;
    case INVALID_MESSAGE:
        return ERROR_INVALID_COMMAND;
        break;
    }
}

string Command_Feedback::getNotificationViewType(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    switch(commandOutcome) {
    case VALID_MESSAGE:
        return validNotificationViewType(executionMessage->getViewType());
        break;
    case INVALID_MESSAGE:
        return invalidNotificationViewtype();
        break;
    }
}

string Command_Feedback::getNotificationChangeSaveFileDirectory(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    switch(commandOutcome) {
    case VALID_MESSAGE:
        return validNotificationChangeSaveFileDirectory(executionMessage->getSaveDirectory());
        break;
    case INVALID_MESSAGE:
        return invalidNotificationSaveFileDirectory();
        break;
    }
}

string Command_Feedback::getNotificationHelpPrompt(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
        return validNotificationHelpPrompt();
}

string Command_Feedback::getNotificationInvalidCommand(Command* executionMessage, CommandOutcome commandOutcome, int viewType) {
    return invalidNotificationCommand();
}

/****************************************************************/

string Command_Feedback::validNotificationAdd(Task* task, int viewType, string textFileName) {
    string taskString;
    taskString = getTaskString(task,viewType);
    sprintf_s(buffer, MESSAGE_ADD.c_str(),taskString.c_str(), textFileName.c_str());
    return buffer;
}

string Command_Feedback::validNotificationDelete(Task* task, int viewType, string textFileName) {
    string taskString;
    taskString = getTaskString(task,viewType);
    sprintf_s(buffer, MESSAGE_DELETE.c_str(),taskString.c_str(), textFileName.c_str());
    return buffer;
}

string Command_Feedback::validNotificationEdit(Task* task, int viewType) {
    string taskString;
    taskString = getTaskString(task,viewType);
    sprintf_s(buffer, MESSAGE_EDIT.c_str(),taskString.c_str());
    return buffer;
}

string Command_Feedback::validNotificationClear(string textFileName) {
    sprintf_s(buffer, MESSAGE_CLEAR.c_str(), textFileName.c_str());
    return buffer;
}

string Command_Feedback::validNotificationSearchTerm(string searchTerm) {
    sprintf_s(buffer, MESSAGE_SEARCH.c_str(), searchTerm.c_str());
    return buffer;
}

string Command_Feedback::validNotificationExitSearch() {
    sprintf_s(buffer, MESSAGE_EXIT_SEARCH.c_str());
    return buffer;
}

string Command_Feedback::validNotificationViewType(int newViewType) {
    sprintf_s(buffer, MESSAGE_VIEW_TYPE.c_str(), newViewType);
    return buffer;
}

string Command_Feedback::validNotificationChangeSaveFileDirectory(string newDirectory) {
    sprintf_s(buffer, MESSAGE_CHANGE_FILE_DIRECTORY.c_str(), newDirectory.c_str());
    return buffer;
}

string Command_Feedback::validNotificationHelpPrompt() {
    return MESSAGE_HELP;
}

/****************************************************************/

string Command_Feedback::invalidNotificationAdd() {
    return ERROR_INVALID_ADD;
}

string Command_Feedback::invalidNotificationDelete() {
    return ERROR_INVALID_DELETE;
}

string Command_Feedback::invalidNotificationEdit() {
    return ERROR_INVALID_EDIT;
}

string Command_Feedback::invalidNotificationViewtype() {
    return ERROR_INVALID_VIEWTYPE;
}

string Command_Feedback::invalidNotificationSaveFileDirectory() {
    return ERROR_INVALID_SAVE_FILE_DIRECTORY;
}

string Command_Feedback::invalidNotificationCommand() {
    return ERROR_INVALID_COMMAND;
}

string Command_Feedback::invalidNotificationUndo() {
    return ERROR_INVALID_UNDO;
}

/****************************************************************/

string Command_Feedback::undoNotificationAdd(Command* executionMessage, int viewType) {
    string taskString;
    taskString = getTaskString(executionMessage->getTask(), viewType);
    sprintf_s(buffer, MESSAGE_UNDO_ADD.c_str(),taskString.c_str());
    return buffer;
}

string Command_Feedback::undoNotificationDel(Command* executionMessage, int viewType) {
    string taskString;
    taskString = getTaskString(executionMessage->getTask(), viewType);
    sprintf_s(buffer, MESSAGE_UNDO_DELETE.c_str(),taskString.c_str());
    return buffer;
}

string Command_Feedback::undoNotificationEdit(Command* executionMessage, int viewType) {
    string taskString;
    taskString = getTaskString(executionMessage->getTask(), viewType);
    sprintf_s(buffer, MESSAGE_UNDO_EDIT.c_str(),taskString.c_str());
    return buffer;
}

string Command_Feedback::undoNotificationClear(Command* executionMessage, int viewType) {
    return MESSAGE_UNDO_CLEAR;
}

string Command_Feedback::undoNotificationViewType(Command* executionMessage, int viewType) {
    sprintf_s(buffer, MESSAGE_UNDO_VIEW_TYPE.c_str(),executionMessage->getViewType());
    return buffer;
}

string Command_Feedback::undoNotificationChangDirectory(Command* executionMessage, int viewType) {
    sprintf_s(buffer, MESSAGE_UNDO_CHANGE_DIRECTORY.c_str(),executionMessage->getSaveDirectory());
    return buffer;
}

/****************************************************************/
```
###### \ViewType.h
``` h
#pragma once
#include <string>
#include <sstream>
#include <vector>
#include <iostream>
#include <list>
#include <assert.h>

#include "Task.h"
#include "Memory.h"

using namespace std;

class ViewType {

#ifndef TESTMODE 
protected: 
#else 
public: 
#endif
    list<Task*> *_taskList;
    vector<string> _colourCoding;
    vector<string> _displayList;
    int _currentDate;
    char buffer[255];

    static const string MESSAGE_DISPLAY_CONTENTS;
    static const string MESSAGE_DATE_SEPERATOR;
    static const string MESSAGE_TIME_SEPERATOR;
    static const string MESSAGE_TIMING_SEPERATOR;
    static const string MESSAGE_VOID_STRING;
    static const string MESSAGE_SPACE_STRING;
    static const string MESSAGE_BRACKETS;
    static const string MESSAGE_FLOATING_TASK;
    static const string MESSAGE_DISPLAY_HEADER;
    static const string MESSAGE_NEW_LINE;
    static const string MESSAGE_EMPTY_LIST;

    static const string COLOUR_DEFAULT;
    static const string COLOUR_NEW;
    static const string COLOUR_DONE;

    string createTaskString(Task* individualTask, int index);

    //overiding functions
    virtual string getComplimentaryString(Task* individualTask);
    virtual string getTimeTaskString(int time);
    virtual string getDateTaskString(int date);
    virtual string getDay(int date);
    virtual string getMonth(int date);
    virtual string getYear(int date);

    string integerToString(int integer);
    string timeToString(string time);

    string formatTaskString(string name , string date1 , string date2 , string time1 , string time2 , string location);
    string formateDateString(string s1, string s2);
    string formateAddSpace(string s);
    string formateAddBracket(string s);

    string colourCoderTag(Task* individualTask, Task* recentTask);

public:
    ViewType(void);
    ViewType(list<Task*> *taskList);
    ViewType(list<Task*> *taskList, int currentDate);
    ~ViewType(void);

    virtual vector<string> createDisplayList();
    vector<string> createSearchList();
    string getTaskString(Task* individualTask);
    vector<string> getColourCoding();
};

```
